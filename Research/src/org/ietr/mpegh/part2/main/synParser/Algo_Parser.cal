package org.ietr.mpegh.part2.main.synParser;

import  std.util.Math.*;
import  std.stdio.Source.*;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  org.sc29.wg11.common.CabacDecodeBinFunction.*;
import  devel.org.sc29.wg11.mpegh.part2.main.synParser.Algo_ParserUtils.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacDecodeBinFunction.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacContextConstantHEVC.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacContextFunctionHEVC.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacParserFunctionHEVC.*;

actor Algo_Parser (uint TILE_INDEX, uint TILE_SPLIT_ENABLE, uint PARSER_ID)
// TilesInfo[0]: number of tiles to decode
// TilesInfo[i>0]: increasing indexes of tiles
				uint ParserSelect,
				uint(size= 8) byte
				==>
				uint(size=16) CUInfo,
				uint(size= 6) IntraPredMode,
				//FIXME default value
				uint(size=16) SliceAddr,
				uint(size=16) TilesCoord,
				uint(size=16) RealTilesCoord,
				uint(size=8)  LcuSizeMax,
				uint(size= 4) PartMode,
				uint(size=2)  IsPicSlcLcu,
				uint(size=2)  LFAcrossSlcTile,
				uint(size=16) PictSize,
				 int(size=16) Poc,
				 int(size= 9) SaoSeLuma,
				 int(size= 9) SaoSeChromaU,
				 int(size= 9) SaoSeChromaV,
				uint(size= 8) SEI_MD5,
				uint(size= 2) SliceType,
				bool          SplitTransform,
				 int(size= 8) TUSize,
				 int(size=16) Coeff,
				bool 		  StrongIntraSmoothing,
				uint(size=14) DispCoord,
				uint(size=9)  PicSizeInMb,
				uint(size= 5) NumRefIdxLxActive,
				uint(size= 4) RefPicListModif,
				 int(size=16) RefPoc,
				 int(size=16) MvPredSyntaxElem,
				bool Cbf,
				bool DBFDisable,
				 int(size=8)  DbfSe,
				 int(size=16) WeightedPredLuma,
				 int(size=16) WeightedPredChroma,
				uint(size=16) TileSize,
				uint(size=16) TileCUInfo,
				uint(size=8)  ReorderPics,
				 int(size= 8) Qp

:
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
        uint(size= 16) se_idx;
	uint(size=32) cnt_i;
	uint(size=10) sps_id;
	uint(size=10) pps_id;
	uint(size= 8) localizeAEB := 0;
	uint NUM_ENTRY_MAX = 64;
	uint entryOffsetsTab[NUM_ENTRY_MAX];
	//uint(size=8) curr_Tile := TilesInfo[1];
	bool byPassFlag := false;
	uint(size=8) TilesInfo[2];


	/**************************************************************************
	 **************************************************************************
	 ********        Bitstream Reader                     *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
	uint counterByte := 0;
	action byte:[ b ] ==>
	guard
		not isFifoFull(fifo)
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
			counterByte := counterByte + 1; //localizeAEB := localizeAEB >> 1;
		if b != EPR_VALUE or zeroByte != 3 then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		else
				if b = EPR_VALUE then //println("AntiEmulationByte");
				//localizeAEB := localizeAEB + 128;
				//println("localize AEB = " + localizeAEB);
			end
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        NAL UNIT                             *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * byte_align_a
	 *************************************************************************/
	byte_align_a : action ==>
	guard
		isFifoFull(fifo)
	do
			byte_align(fifo); //localizeAEB := localizeAEB >> 1;
	end
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		not IsStartCode(fifo) and isFifoFull(fifo)
	do
		flushBits( 8, fifo );
		if DEBUG_BITSTREAM then
			println("start_code.search");
		end
	end
	start_code.done: action ==>
	guard
		IsStartCode(fifo) and isFifoFull(fifo)
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end
	/**************************************************************************
	 * read_nal_unit_header
	 *************************************************************************/
		uint temporal_id := 0;
	uint(size= 6) nal_unit_type;

	read_nal_unit_header : action ==>
	guard
		isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		if DEBUG_BITSTREAM then
			println("=========== NAL_UNIT ===========");
				flushBits_name(1, fifo,
				"forbidden_zero_bit                      ");
				vld_u_name(6, fifo, res,
				"nal_unit_type                           ");
			nal_unit_type := res[0];
				flushBits_name(6, fifo,
				"nuh_reserved_zero_6bits                 ");
				vld_u_name(3, fifo, res,
				"nuh_temporal_id_plus1                   ");
		else
			flushBits( 1, fifo );
			vld_u(  6, fifo, res);
			nal_unit_type := res[0];
			flushBits( 6, fifo  );
			vld_u(  3, fifo, res);
				temporal_id := res[0] - 1;
		end
		se_idx := 1;
	end
	/**************************************************************************
	 * look_for.VPS_header
	 *************************************************************************/
	look_for.VPS_header: action ==>
	guard
		nal_unit_type = NAL_VPS
	do
		if DEBUG_PARSER then
			println("=========== Video Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.SEI_header
	 *************************************************************************/
	look_for.SEI_header: action ==>
	guard
		nal_unit_type = NAL_SEI_PREFIX or nal_unit_type = NAL_SEI_SUFFIX
	do
		if DEBUG_PARSER then
			println("=========== SEI message ===========");
		end
	end
	/**************************************************************************
	 * look_for.SPS_header
	 *************************************************************************/
	look_for.SPS_header: action ==>
	guard
		nal_unit_type = NAL_SPS
	do
		if DEBUG_PARSER then
			println("=========== Sequence Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.PPS_header
	 *************************************************************************/
	look_for.PPS_header: action ==>
	guard
		nal_unit_type = NAL_PPS
	do
		if DEBUG_PARSER then
			println("=========== Picture Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.Slice_header
	 *************************************************************************/
	bool bypassFlag := false;
	
	look_for.Slice_header: action ParserSelect:[s]==>
	guard
		(nal_unit_type = NAL_TRAIL_R    or
		 nal_unit_type = NAL_TSA_N      or
		 nal_unit_type = NAL_TSA_R      or
		 nal_unit_type = NAL_TRAIL_N    or
		 nal_unit_type = NAL_STSA_N		or
		 nal_unit_type = NAL_STSA_R		or
		 nal_unit_type = NAL_RADL_N		or
		 nal_unit_type = NAL_RADL_R		or
		 nal_unit_type = NAL_RASL_N		or
		 nal_unit_type = NAL_RASL_R		or
		 nal_unit_type = NAL_IDR_N_LP	or
		 nal_unit_type = NAL_BLA_W_LP   or
		 nal_unit_type = NAL_BLA_W_RADL or
		 nal_unit_type = NAL_BLA_N_LP   or
		 nal_unit_type = NAL_IDR_W_DLP  or
		 nal_unit_type = NAL_CRA_NUT    or
		 nal_unit_type = NAL_RASL_R)
	do
		if s = PARSER_ID then
			bypassFlag := false;
		else
			bypassFlag := true;
		end
		if DEBUG_PARSER then
			println("=========== Slice ===========");
		end
	end
	/**************************************************************************
	 * look_for_other_header
	 *************************************************************************/
	look_for_other_header: action ==>
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Video Parameter Set HEADER           *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 3) vps_max_sub_layers_minus1;
	uint(size= 6) vps_max_nuh_reserved_zero_layer_id;
	uint(size= 1) vps_timing_info_present_flag;
	uint(size=10) vps_num_op_sets_minus1;
	uint(size=10) vps_num_hrd_parameters;
	uint(size= 8) video_sequence_id := 0;

	/**************************************************************************
	 * read_VPS_Header.se_idx_1
	 *************************************************************************/
	read_VPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		video_sequence_id := video_sequence_id + 1;
		vld_u_name(  4, fifo, res, "vps_video_parameter_set_id              ");
		vld_u_name(  2, fifo, res, "vps_reserved_three_2bits                ");
		vld_u_name(  6, fifo, res, "vps_reserved_zero_6bits                 ");
		vld_u_name(  3, fifo, res, "vps_max_sub_layers_minus1               ");
		vps_max_sub_layers_minus1 := res[0];
		vld_u_name(  1, fifo, res, "vps_temporal_id_nesting_flag            ");
		vld_u_name( 16, fifo, res, "vps_reserved_ffff_16bits                ");
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_2
	 *************************************************************************/
	read_VPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
				vld_u_name(2, fifo, res,
				"XXX_profile_space[]                     ");
				vld_u_name(1, fifo, res,
				"XXX_tier_flag[]                         ");
				vld_u_name(5, fifo, res,
				"XXX_profile_idc[]                       ");
			foreach int i in 0 .. 31 do
					vld_u_name(1, fifo, res,
					"XXX_profile_compatibility_flag[][j]     ");
			end
				vld_u_name(1, fifo, res,
				"general_progressive_source_flag         ");
				vld_u_name(1, fifo, res,
				"general_interlaced_source_flag          ");
				vld_u_name(1, fifo, res,
				"general_non_packed_constraint_flag      ");
				vld_u_name(1, fifo, res,
				"general_frame_only_constraint_flag      ");
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_3
	 *************************************************************************/
	read_VPS_Header.se_idx_3 : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo)
	var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
			vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[0..15]         ");
			vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[16..31]        ");
			vld_u_name( 12, fifo, res, "XXX_reserved_zero_44bits[32..43]        ");
		end
		vld_u_name(  8, fifo, res, "general_level_idc                       ");
		cnt_i  := 0;
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_4
	 *************************************************************************/
	bool profile_present_flag := true;
	bool sub_layer_profile_present_flag;
	bool sub_layer_level_present_flag;

	read_VPS_Header.se_idx_4.loop1 : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		cnt_i < vps_max_sub_layers_minus1
	var
		uint(size = 32) res[1]
	do
		res[0] := 0;
		if profile_present_flag then
			vld_u_name(  1, fifo, res, "sub_layer_profile_present_flag[i]       ");
		end
		sub_layer_profile_present_flag := (res[0] = 1);
		vld_u_name(  1, fifo, res, "sub_layer_level_present_flag[i]         ");
		sub_layer_level_present_flag := (res[0] = 1);
		cnt_i := cnt_i + 1;
	end

	read_VPS_Header.se_idx_4.insertedCond : action ==>
	guard
		se_idx = 40 and isFifoFull(fifo)
	do
		if (vps_max_sub_layers_minus1 > 0) then
			foreach int k in vps_max_sub_layers_minus1 .. 7 do
				flushBits_name( 2, fifo,    "reserved_zero_2bits[ i ]                ");
			end
		end
		se_idx := 41;
	end

	read_VPS_Header.se_idx_4.loop2 : action ==>
	guard
		se_idx = 41 and isFifoFull(fifo),
		cnt_i < vps_max_sub_layers_minus1
	var
		uint(size = 32) res[1]
	do
		if (profile_present_flag and sub_layer_profile_present_flag) then
			vld_u_name(  2, fifo, res, "sub_layer_profile_space[i]              ");
			vld_u_name(  1, fifo, res, "sub_layer_tier_flag[i]                  ");
			vld_u_name(  5, fifo, res, "sub_layer_profile_idc[i]                ");
			foreach int j in 0 .. 31 do
					vld_u_name(1, fifo, res,
					"sub_layer_profile_compatibility_flags[i][j]");
			end
				flushBits_name(16, fifo,
				"sub_layer_reserved_zero_16bits[i]         ");
		end
		if (sub_layer_level_present_flag) then
			vld_u_name(  1, fifo, res, "sub_layer_level_idc[i]                  ");
		end
		cnt_i := cnt_i + 1;
	end
	read_VPS_Header.se_idx_4.loop1End : action ==>
	guard
		se_idx = 4 ,
		cnt_i = vps_max_sub_layers_minus1
		do
		cnt_i  := 0;
		se_idx := 40;
	end

	read_VPS_Header.se_idx_4.loop2End : action ==>
	guard
		se_idx = 41 ,
		cnt_i = vps_max_sub_layers_minus1
	do
		se_idx := 42;
		cnt_i := 0;
	end

	read_VPS_Header.se_idx_4.decodeInfoPresentFlag : action ==>
	guard
		se_idx = 42 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "vps_sub_layer_ordering_info_present_flag");
		if res[0] = 1 then
			cnt_i  := 0;
		else
			cnt_i  := vps_max_sub_layers_minus1;
		end
		se_idx := 5;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_5
	 *************************************************************************/
	read_VPS_Header.se_idx_5.loop11 : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo),
		cnt_i < vps_max_sub_layers_minus1 +1
	var
		int(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "vps_max_dec_pic_buffering[i]            ");
		vld_ue_name(    fifo, res, "vps_num_reorder_pics[i]                 ");
		vld_ue_name(    fifo, res, "vps_max_latency_increase[i]             ");
		cnt_i := cnt_i + 1;
	end
	read_VPS_Header.se_idx_5.loopEnd : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo),
		cnt_i = vps_max_sub_layers_minus1 + 1
	var
		uint(size=32) res[1]
	do
		vld_u_name(  6, fifo, res, "vps_max_nuh_reserved_zero_layer_id      ");
		vps_max_nuh_reserved_zero_layer_id := res[0];
		vld_ue_name(    fifo, res, "vps_max_op_sets_minus1                  ");
		vps_num_op_sets_minus1 := res[0];
		cnt_i  := 1;
		cnt_i  := vps_num_op_sets_minus1 + 1; // TODO : bypass layer_id_included_flag()
		se_idx := 6;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_6
	 *************************************************************************/
	read_VPS_Header.se_idx_6.loop : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo),
		cnt_i <= vps_num_op_sets_minus1
	var
		uint(size=32) res[1]
	do
		foreach int(size=8) i in 0 .. vps_max_nuh_reserved_zero_layer_id - 1 do
			vld_u_name(  1, fifo, res, "layer_id_included_flag[][i]             ");
		end
		cnt_i := cnt_i + 1;
	end
	read_VPS_Header.se_idx_6.loopEnd : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo),
		cnt_i = vps_num_op_sets_minus1 + 1
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "vps_timing_info_present_flag            ");
		vps_timing_info_present_flag := res[0];
		if vps_timing_info_present_flag = 1 then
			se_idx := se_idx + 1;
		else
			se_idx := 10;
		end
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_7
	 *************************************************************************/
	read_VPS_Header.se_idx_7 : action ==>
	guard
		se_idx = 7 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name( 32, fifo, res, "vps_num_units_in_tick                   ");
		vld_u_name( 32, fifo, res, "vps_time_scale                          ");
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_8
	 *************************************************************************/
	read_VPS_Header.se_idx_8 : action ==>
	guard
		se_idx = 8 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "vps_poc_proportional_to_timing_flag     ");
		if res[0] = 1 then
			vld_ue_name(    fifo, res, "vps_num_ticks_poc_diff_one_minus1       ");
		end
		vld_ue_name(    fifo, res, "vps_num_hrd_parameters                  ");
		vps_num_hrd_parameters := res[0];
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_9
	 *************************************************************************/
	read_VPS_Header.se_idx_9.loop : action ==>
	guard
		se_idx = 9 and isFifoFull(fifo),
		cnt_i < vps_num_hrd_parameters
	var
		uint(size=32) res[1],
		uint(size= 1) cprms_present_flag := 0
	do
		vld_ue_name(    fifo, res, "hrd_op_set_idx[i]                       ");
		if cnt_i > 0 then
			vld_u_name(  1, fifo, res, "cprms_present_flag[i]                   ");
			cprms_present_flag := res[0];
		end
		if cprms_present_flag = 1 then
			println("not support for vps_num_hrd_parameters != 0");
		end
		cnt_i := cnt_i + 1;
	end
	read_VPS_Header.se_idx_9.loopEnd : action ==>
	guard
		se_idx = 9,
		cnt_i = vps_num_hrd_parameters
	do
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header_done
	 *************************************************************************/
	read_VPS_Header_done : action ==>
	guard
		se_idx = 10 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
			vld_u_name(1, fifo, res,
			"vps_extension_flag                      ");
		if res[0] = 1 then
			println("not support for vps_extension_flag != 0");
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        SEI message                          *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SEI_Header.se_idx_1
	 *************************************************************************/
	uint(size=16) sei_payloadType;
	uint(size=16) sei_payloadSize;
	uint(size=16) sei_payloadPosition;
	uint(size= 8) sei_idx;
	/**************************************************************************
	 * read_SEI_Header.init
	 *************************************************************************/
	read_SEI_Header.init : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	do
		sei_payloadType     := 0;
		sei_payloadSize     := 0;
		sei_payloadPosition := 0;
		se_idx              := se_idx + 1;
		sei_idx             := 1;
	end
	/**************************************************************************
	 * read_SEI_Header.payload_type
	 *************************************************************************/
	read_SEI_Header.payload_type : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "payload_type                            ");
		sei_payloadType := sei_payloadType + res[0];
		if res[0] != 0xFF then
			se_idx := se_idx + 1;
	    else
        	se_idx := 6;
		end
	end
	/**************************************************************************
	 * read_SEI_Header.payload_size
	 *************************************************************************/
	read_SEI_Header.payload_size : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(8, fifo, res,
			"payload_size                            ");
		sei_payloadSize := sei_payloadSize + res[0];
		if res[0] != 0xFF then // sei_payload( payloadType, payloadSize )
			se_idx := se_idx + 1;
        else
        	se_idx := 6;
		end
	end
	    
    read_SEI_Header.skipSEI : action ==>
    guard
   		se_idx = 4 and isFifoFull(fifo),
    	sei_idx = 1 and sei_payloadType != 132
    do
        se_idx := 6;
    end
	/**************************************************************************
	 * read_SEI_Header.decoded_picture_hash
	 *************************************************************************/
	uint(size= 8) sei_cIdx;
	uint(size= 8) sei_i;
	uint(size= 8) sei_hash_type;
	read_SEI_Header.decoded_picture_hash.init : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		sei_idx = 1 and sei_payloadType = 132
	var
		uint(size=32) res[1]
	do
		if DEBUG_PARSER then
			println("=========== Decoded picture hash SEI message ===========");
		end
		vld_u_name(  8, fifo, res, "hash_type                               ");
		sei_payloadPosition := sei_payloadPosition + 8;
		sei_hash_type       := res[0];
		sei_cIdx            := 0;
		sei_i               := 0;
		sei_idx             := sei_idx + 1;
	end
	read_SEI_Header.decoded_picture_hash.loop : action ==> SEI_MD5:[res[0]]
	guard
		se_idx = 4 and isFifoFull(fifo),
		sei_idx = 2 and sei_payloadType = 132,
		sei_cIdx < 3, /*if sps_chroma_format_idc[sps_id] = 0 then 1 else 3 end,*/
		sei_i    < 16
	var
		uint(size=32) res[1]
	do
		if sei_hash_type = 0 then
			vld_u_name(  8, fifo, res, "picture_md5                             ");
			sei_payloadPosition := sei_payloadPosition +  8;
			sei_i               := sei_i + 1;
				elsif sei_hash_type = 1 then vld_u_name(16, fifo, res,
				"picture_crc                             ");
			sei_payloadPosition := sei_payloadPosition + 16;
			sei_i               := 16;
				elsif sei_hash_type = 2 then vld_u_name(32, fifo, res,
				"picture_checksum                        ");
			sei_payloadPosition := sei_payloadPosition + 32;
			sei_i               := 16;
		end
		if sei_i = 16 then
			sei_i := 0;
			sei_cIdx := sei_cIdx + 1;
				if sei_cIdx = 3

				/*if sps_chroma_format_idc[sps_id] = 0 then 1 else 3 end*/
				then
				se_idx := se_idx + 1;
			end
		end
	end
	/**************************************************************************
	 * read_SEI_Header.sei_payload_end
	 *************************************************************************/
	read_SEI_Header.sei_payload_end : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		if not(isByteAlign(fifo) and sei_payloadPosition = (sei_payloadSize << 3)) then
//			if payload_extension_present( ) then
//				reserved_payload_extension_data
//			end
			vld_u_name(  1, fifo, res, "bit_equal_to_one                        ");
			while not isByteAlign(fifo) do
				vld_u_name(  1, fifo, res, "bit_equal_to_zero                       ");
			end
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SEI_Header.done
	 *************************************************************************/
	read_SEI_Header_done : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "rbsp_trailing_bits");
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Sequence Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SPS_Header.se_idx_1
	 *************************************************************************/
	uint(size= 4) sps_max_sub_layers_minus1[NB_MAX_SPS];
	uint(size=16) sps_pic_width_in_luma_samples[NB_MAX_SPS];
	uint(size=16) sps_pic_height_in_luma_samples[NB_MAX_SPS];
	uint(size= 1) sps_separate_colour_plane_flag[NB_MAX_SPS];
	uint(size= 2) sps_chroma_format_idc[NB_MAX_SPS];

	read_SPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(4, fifo, res,
			"sps_video_parameter_set_id              ");
		vld_u_name(3, fifo, res,
			"sps_max_sub_layers_minus1               ");
		sps_max_sub_layers_minus1[sps_id] := res[0];
		vld_u_name(1, fifo, res,
			"sps_temporal_id_nesting_flag            ");
		se_idx := 20;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_20
	 *************************************************************************/
	read_SPS_Header.se_idx_20 : action ==>
	guard
		se_idx = 20 and isFifoFull(fifo)
   var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
			vld_u_name(  2, fifo, res, "XXX_profile_space[]                     ");
			vld_u_name(  1, fifo, res, "XXX_tier_flag[]                         ");
			vld_u_name(  5, fifo, res, "XXX_profile_idc[]                       ");
			foreach int i in 0 .. 31 do
					vld_u_name(1, fifo, res,
					"XXX_profile_compatibility_flag[][j]     ");
			end
			vld_u_name(  1, fifo, res, "general_progressive_source_flag         ");
			vld_u_name(  1, fifo, res, "general_interlaced_source_flag          ");
			vld_u_name(  1, fifo, res, "general_non_packed_constraint_flag      ");
			vld_u_name(  1, fifo, res, "general_frame_only_constraint_flag      ");
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_20
	 *************************************************************************/
	read_SPS_Header.se_idx_21 : action ==>
	guard
		se_idx = 21 and isFifoFull(fifo)
	   var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
			vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[0..15]         ");
			vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[16..31]        ");
			vld_u_name( 12, fifo, res, "XXX_reserved_zero_44bits[32..43]        ");
		end
		vld_u_name(  8, fifo, res, "general_level_idc                       ");
		cnt_i  := 0;
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_22
	 *************************************************************************/
	bool sps_sub_layer_level_present_flag := false;
	bool sps_profile_present_flag := true;
	bool sps_sub_layer_profile_present_flag := false;

	read_SPS_Header.se_idx_22.loop1 : action ==>
	guard
		se_idx = 22 and isFifoFull(fifo),
		cnt_i < sps_max_sub_layers_minus1[sps_id]
	var
		uint(size = 32) res[1]
	do
		res[0] := 0;
		if sps_profile_present_flag then
			vld_u_name(  1, fifo, res, "sub_layer_profile_present_flag[i]       ");
		end
		sps_sub_layer_profile_present_flag := (res[0] = 1);
		vld_u_name(  1, fifo, res, "sub_layer_level_present_flag[i]         ");
		sps_sub_layer_level_present_flag := (res[0] = 1);
		cnt_i := cnt_i + 1;
	end

	read_SPS_Header.se_idx_22.loopEnd1 : action ==>
	guard
		se_idx = 22 and isFifoFull(fifo),
		cnt_i = sps_max_sub_layers_minus1[sps_id]
	do
		cnt_i := 0;
		se_idx := 221;
	end

	read_SPS_Header.se_idx_22.indertedCond : action ==>
	guard
		se_idx = 221 and isFifoFull(fifo)
	do
		if sps_max_sub_layers_minus1[sps_id] > 0 then
			foreach int i in sps_max_sub_layers_minus1[sps_id] .. 7 do
					flushBits_name(2, fifo,
					"reserved_zero_2bits[i]                    ");
			end
		end
		se_idx := 222;
	end

	read_SPS_Header.se_idx_22.loop2 : action ==>
	guard
		se_idx = 222 and isFifoFull(fifo),
		cnt_i < sps_max_sub_layers_minus1[sps_id]
	var
		uint(size = 32) res[1]
	do
		if (sps_profile_present_flag and sps_sub_layer_profile_present_flag) then
			vld_u_name(  2, fifo, res, "sub_layer_profile_space[i]              ");
			vld_u_name(  1, fifo, res, "sub_layer_tier_flag[i]                  ");
			vld_u_name(  5, fifo, res, "sub_layer_profile_idc[i]                ");
			foreach int j in 0 .. 31 do
				vld_u_name(  1, fifo, res, "sub_layer_profile_compatibility_flags[i][j]");
			end
			flushBits_name(16, fifo,    "sub_layer_reserved_zero_16bits[i]         ");
		end
		if (sps_sub_layer_level_present_flag) then
			vld_u_name(  1, fifo, res, "sub_layer_level_idc[i]                  ");
		end
		cnt_i := cnt_i + 1;
	end
	read_SPS_Header.se_idx_22.loopEnd : action ==>
	guard
		se_idx = 222 and isFifoFull(fifo),
		cnt_i = sps_max_sub_layers_minus1[sps_id]
	do
		se_idx := 11;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_1_1
	 *************************************************************************/
	read_SPS_Header.se_idx_1_1 : action ==>
	guard
		se_idx = 11 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "sps_seq_parameter_set_id                ");
		sps_id := res[0];
			vld_ue_name(fifo, res,
				"chroma_format_idc                       ");
		sps_chroma_format_idc[sps_id] := res[0];
		if res[0] = 3 then
			vld_u_name(1, fifo, res,
				"separate_colour_plane_flag              ");
			sps_separate_colour_plane_flag[sps_id] := res[0];
		end
		vld_ue_name(fifo, res,
			"pic_width_in_luma_samples               ");
		sps_pic_width_in_luma_samples[sps_id] := res[0];
		vld_ue_name(fifo, res,
			"pic_height_in_luma_samples              ");
		sps_pic_height_in_luma_samples[sps_id] := res[0];
		se_idx := 2;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_2
	 *************************************************************************/
	uint(size= 8) sps_log2_max_pic_order_cnt_lsb_minus4[NB_MAX_SPS];
	uint(size=32) max_poc_lsb[NB_MAX_SPS];
	int sps_bit_depth_luma_minus8[NB_MAX_SPS];
	int sps_bit_depth_chroma_minus8[NB_MAX_SPS];

	read_SPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size=1)  conformance_window_flag
	do
		vld_u_name(  1, fifo, res, "conformance_window_flag                 ");
		conformance_window_flag := res[0];
		if conformance_window_flag = 1 then
				vld_ue_name(fifo, res,
				"conf_win_left_offset                    ");
				vld_ue_name(fifo, res,
				"conf_win_right_offset                   ");
				vld_ue_name(fifo, res,
				"conf_win_top_offset                     ");
				vld_ue_name(fifo, res,
				"conf_win_bottom_offset                  ");
		end
			vld_ue_name(fifo, res,
			"sps_bit_depth_luma_minus8                   ");
		sps_bit_depth_luma_minus8[sps_id] := res[0];
			vld_ue_name(fifo, res,
			"sps_bit_depth_chroma_minus8                 ");
		sps_bit_depth_chroma_minus8[sps_id] := res[0];
			vld_ue_name(fifo, res,
			"log2_max_pic_order_cnt_lsb_minus4       ");
		sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] := res[0];
			max_poc_lsb[sps_id] := 1 <<
			(sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4);
			vld_u_name(1, fifo, res,
			"sps_sub_layer_ordering_info_present_flag");
		if res[0] = 1 then
			cnt_i  := 0;
		else
			cnt_i  := sps_max_sub_layers_minus1[sps_id];
		end
		se_idx := se_idx + 1;
	end

	/**************************************************************************
	 * read_SPS_Header.se_idx_3
	 *************************************************************************/
	uint sps_num_reorder_pics[NB_MAX_SPS];
	
	read_SPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo),
		cnt_i <= sps_max_sub_layers_minus1[sps_id]
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "sps_max_dec_pic_buffering               ");
		vld_ue_name(    fifo, res, "sps_num_reorder_pics                    ");
		sps_num_reorder_pics[sps_id] := res[0];
		vld_ue_name(    fifo, res, "sps_max_latency_increase                ");
		cnt_i := cnt_i + 1;
	end

	read_SPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3,
		cnt_i = sps_max_sub_layers_minus1[sps_id] + 1
	do
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/
		uint(size= 8) sps_log2_min_coding_block_size[NB_MAX_SPS];
	    uint(size= 8) sps_log2_min_pu_size[NB_MAX_SPS];
	    uint(size= 8) sps_min_pu_width[NB_MAX_SPS];
	uint(size= 8) sps_log2_diff_max_min_coding_block_size[NB_MAX_SPS];
		uint(size= 8) sps_log2_min_transform_block_size[NB_MAX_SPS];
	uint(size= 8) sps_log2_diff_max_min_transform_block_size[NB_MAX_SPS];
	uint(size=16) sps_maxCUWidth[NB_MAX_SPS];
	uint(size=16) sps_addCUDepth[NB_MAX_SPS];

	read_SPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_min_coding_block_size_minus3       ");
				sps_log2_min_coding_block_size[sps_id] := res[0] + 3;
			vld_ue_name(fifo, res,
			"log2_diff_max_min_coding_block_size     ");
		sps_log2_diff_max_min_coding_block_size[sps_id] := res[0];
			vld_ue_name(fifo, res,
			"log2_min_transform_block_size_minus2    ");
		sps_log2_min_transform_block_size[sps_id] := res[0] + 2;
			vld_ue_name(fifo, res,
			"log2_diff_max_min_transform_block_size  ");
		sps_log2_diff_max_min_transform_block_size[sps_id] := res[0];
			sps_maxCUWidth[sps_id] := 1 << (Log2MinCbSize +
			sps_log2_diff_max_min_coding_block_size[sps_id]);
		sps_addCUDepth[sps_id] := 0;
			while ((sps_maxCUWidth[sps_id] >>
			sps_log2_diff_max_min_coding_block_size[sps_id]) > (1 <<
			(sps_log2_min_transform_block_size[sps_id] +
			sps_log2_diff_max_min_coding_block_size[sps_id]))) do
			sps_addCUDepth[sps_id] := sps_addCUDepth[sps_id] + 1;
		end
	        sps_log2_min_pu_size[sps_id] := sps_log2_min_coding_block_size[sps_id] - 1;
	        sps_min_pu_width[sps_id] := sps_pic_width_in_luma_samples[sps_id]  >> sps_log2_min_pu_size[sps_id];
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_5
	 *************************************************************************/
	uint(size= 8) sps_max_transform_hierarchy_depth_inter[NB_MAX_SPS];
	uint(size= 8) sps_max_transform_hierarchy_depth_intra[NB_MAX_SPS];
	uint(size= 1) sps_scaling_list_enabled_flag[NB_MAX_SPS];
	uint(size=16) sps_ctb_width[NB_MAX_SPS];
	    uint(size=16) sps_ctb_height[NB_MAX_SPS];
	uint(size=16) sps_log2_ctb_size[NB_MAX_SPS];
	int(size=32) min_cb_width;


	read_SPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_inter     ");
		sps_max_transform_hierarchy_depth_inter[sps_id] := res[0];
			vld_ue_name(fifo, res,
			"max_transform_hierarchy_depth_intra     ");
		sps_max_transform_hierarchy_depth_intra[sps_id] := res[0];
			vld_u_name(1, fifo, res,
			"sps_scaling_list_enabled_flag           ");
		sps_scaling_list_enabled_flag[sps_id] := res[0];
	        
		min_cb_width := sps_pic_width_in_luma_samples[sps_id] >> sps_log2_min_coding_block_size[sps_id];
		sps_log2_ctb_size[sps_id] := sps_log2_min_coding_block_size[sps_id] + sps_log2_diff_max_min_coding_block_size[sps_id];
		sps_ctb_width[sps_id] := (sps_pic_width_in_luma_samples[sps_id]  + (1 << sps_log2_ctb_size[sps_id]) - 1) >> sps_log2_ctb_size[sps_id];
	        sps_ctb_height[sps_id] := (sps_pic_height_in_luma_samples[sps_id]  + (1 << sps_log2_ctb_size[sps_id]) - 1) >> sps_log2_ctb_size[sps_id];

		if sps_scaling_list_enabled_flag[sps_id] = 1 then
			se_idx := 60;
		else
			se_idx := 6;
		end
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/
	uint(size= 1) sps_sample_adaptive_offset_enabled_flag[NB_MAX_SPS];
	uint(size= 8) sps_num_short_term_ref_pic_sets[NB_MAX_SPS];
	uint(size= 1) sps_pcm_enabled_flag[NB_MAX_SPS];
	uint(size= 1) amp_enabled_flag;
	uint(size= 8) sps_sl[NB_MAX_SPS][4][6][64];
	uint(size= 8) sps_sl_dc[NB_MAX_SPS][2][6];
	int sps_size_id := 0;
	int sps_size_id_matrixCase;
	int sps_matrix_id := 0;
	int sps_coef_num :=0;
	int sps_pos;
	int sps_scaling_list_delta_coef;
	int sps_next_coef;

	read_SPS_Header.se_idx_60 : action ==>
	guard
		se_idx = 60 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) sps_scaling_list_data_present_flag
	do
			foreach int matrixId in 0 .. 5 do // 4x4 default is 16
			foreach int i in 0 .. 15 do
				sps_sl[sps_id][0][matrixId][i] := 16;
			end
			sps_sl_dc[sps_id][0][matrixId] := 16; // default for 16x16
			sps_sl_dc[sps_id][1][matrixId] := 16; // default for 32x32
		end
		foreach int i in 0 .. 63 do
			sps_sl[sps_id][1][0][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][1][1][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][1][2][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][1][3][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][1][4][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][1][5][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][2][0][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][2][1][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][2][2][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][2][3][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][2][4][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][2][5][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][3][0][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][3][1][i] := default_scaling_list_inter[i];
		end
		vld_u_name(  1, fifo, res, "sps_scaling_list_data_present_flag      ");
		sps_scaling_list_data_present_flag := res[0];
		if sps_scaling_list_data_present_flag = 1 then
			se_idx := 61;
		else
			se_idx := 6;
		end
	end

	read_SPS_Header.se_idx_61_loopSize_id : action ==>
	guard
		se_idx = 61 and isFifoFull(fifo) , sps_size_id < 4
	do
		if sps_size_id = 3 then sps_size_id_matrixCase := 2; else sps_size_id_matrixCase := 6; end
		se_idx := 62;
	end

	read_SPS_Header.se_idx_61_loopMatrix_id : action ==>
	guard
		se_idx = 62 and isFifoFull(fifo) , sps_matrix_id < sps_size_id_matrixCase
	var
		uint(size=32) res[1],
		int delta,
		int size_id_memcpyCase,
		uint(size= 8) sps_scaling_list_pred_mode_flag[4][6],
		uint(size= 32) sps_scaling_list_dc_coef[2][6]
	do
		vld_u_name(  1, fifo, res, "scaling_list_pred_mode_flag             ");
		sps_scaling_list_pred_mode_flag[sps_size_id][sps_matrix_id] := res[0];
		if sps_scaling_list_pred_mode_flag[sps_size_id][sps_matrix_id] = 0 then
			vld_ue_name(    fifo, res, "delta                                   ");
				delta := res[0]; // Only need to handle non-zero delta. Zero means default, which should already be in the arrays.
				if delta != 0 then // Copy from previous array.
				if (sps_matrix_id - delta < 0) then
					println("Invalid delta in scaling list data");
				end
					if sps_size_id > 0 then
						size_id_memcpyCase := 64;
					else
						size_id_memcpyCase := 16;
					end
				foreach int k in 0 .. size_id_memcpyCase - 1 do
						sps_sl[sps_id][sps_size_id][sps_matrix_id][k] :=
						sps_sl[sps_id][sps_size_id][sps_matrix_id - delta][k];
				end
				if (sps_size_id > 1) then
						sps_sl_dc[sps_id][sps_size_id - 2][sps_matrix_id] :=
						sps_sl_dc[sps_id][sps_size_id - 2][sps_matrix_id - delta];
				end
			end
			sps_matrix_id := sps_matrix_id + 1;
		else
			sps_next_coef := 8;
			sps_coef_num := min(64, (1  <<  (4 + (sps_size_id  <<  1))));
			if (sps_size_id > 1) then
				vld_se_name(    fifo, res, "scaling_list_dc_coef                    ");
				sps_scaling_list_dc_coef[sps_size_id - 2][sps_matrix_id] := res[0] + 8;
					sps_next_coef := sps_scaling_list_dc_coef[sps_size_id -
					2][sps_matrix_id];
				sps_sl_dc[sps_id][sps_size_id - 2][sps_matrix_id] := sps_next_coef;
			end
			se_idx := 63;
			cnt_i := 0;
		end
	end

	read_SPS_Header.se_idx_63_loopNumCoef : action ==>
	guard
		se_idx = 63 and isFifoFull(fifo), cnt_i < sps_coef_num
	var
		uint(size=32) res[1]
	do
		if (sps_size_id = 0) then
			sps_pos := 4 * hevc_diag_scan4x4_y[cnt_i] + hevc_diag_scan4x4_x[cnt_i];
		else
			sps_pos := 8 * hevc_diag_scan8x8_y[cnt_i] + hevc_diag_scan8x8_x[cnt_i];
		end
		vld_se_name(    fifo, res, "scaling_list_delta_coef                 ");
		sps_scaling_list_delta_coef := res[0];
		sps_next_coef := (sps_next_coef + sps_scaling_list_delta_coef + 256) mod 256;
		sps_sl[sps_id][sps_size_id][sps_matrix_id][sps_pos] := sps_next_coef;
		cnt_i := cnt_i +1;
	end

	read_SPS_Header.se_idx_63_loopNumCoefEnd : action ==>
	guard
		se_idx = 63 and isFifoFull(fifo), cnt_i = sps_coef_num
	do
		cnt_i := 0;
		sps_matrix_id := sps_matrix_id + 1;
		se_idx := 62;
	end


	read_SPS_Header.se_idx_62_loopMatrix_id_End : action ==>
	guard
		se_idx = 62 and isFifoFull(fifo) , sps_matrix_id = sps_size_id_matrixCase
	do
		sps_size_id := sps_size_id + 1;
		sps_matrix_id := 0;
		se_idx := 61;
	end

	read_SPS_Header.se_idx_61_size_id_loopEnd : action ==>
	guard
		se_idx = 61 and isFifoFull(fifo) , sps_size_id = 4
	do
		sps_size_id := 0;
		se_idx := 6;
	end

		uint log2_min_pcm_cb_size[NB_MAX_SPS];
		uint log2_max_pcm_cb_size[NB_MAX_SPS];
		uint pcm_bit_depth[NB_MAX_SPS];
		uint pcm_bit_depth_chroma[NB_MAX_SPS];
		uint pcm_loop_filter_disable_flag[NB_MAX_SPS];
		

	read_SPS_Header.se_idx_6 : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
			vld_u_name(1, fifo, res,
			"amp_enabled_flag                        ");
		amp_enabled_flag := res[0];
			vld_u_name(1, fifo, res,
			"sample_adaptive_offset_enabled_flag     ");
		sps_sample_adaptive_offset_enabled_flag[sps_id] := res[0];
			vld_u_name(1, fifo, res,
			"pcm_enabled_flag                        ");
		sps_pcm_enabled_flag[sps_id] := res[0];
		if sps_pcm_enabled_flag[sps_id] = 1 then
				vld_u_name(4, fifo, res,
				"pcm_sample_bit_depth_luma_minus1        ");
	        	pcm_bit_depth[sps_id] := res[0] + 1;
				vld_u_name(4, fifo, res,
				"pcm_sample_bit_depth_chroma_minus1      ");
	        	pcm_bit_depth_chroma[sps_id] := res[0] + 1;
				vld_ue_name(fifo, res,
				"log2_min_pcm_luma_coding_block_size_minus3");
				log2_min_pcm_cb_size[sps_id] := res[0] + 3;
				vld_ue_name(fifo, res,
				"log2_diff_max_min_pcm_luma_coding_block_size");
				log2_max_pcm_cb_size[sps_id] := log2_min_pcm_cb_size[sps_id] +
				res[0];
				vld_u_name(1, fifo, res,
				"pcm_loop_filter_disable_flag            ");
	        	pcm_loop_filter_disable_flag[sps_id] := res[0];
		end
			vld_ue_name(fifo, res,
			"num_short_term_ref_pic_sets             ");
		sps_num_short_term_ref_pic_sets[sps_id] := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_7
	 *************************************************************************/
	int(size=8) pcRPS[NB_MAX_SPS][NB_MAX_PICS+1][PC_RPS_STRUCT_SIZE];

	read_SPS_Header.se_idx_7.loop : action ==>
	guard
		se_idx = 7 and isFifoFull(fifo),
		cnt_i < sps_num_short_term_ref_pic_sets[sps_id]
	do
		parseShortTermRefPicSet(sps_id, cnt_i, sps_num_short_term_ref_pic_sets[sps_id], fifo, pcRPS);
		cnt_i := cnt_i + 1;
	end
	read_SPS_Header.se_idx_7.loopEnd : action ==>
	guard
		se_idx = 7,
		cnt_i = sps_num_short_term_ref_pic_sets[sps_id]
	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_8
	 *************************************************************************/
	uint(size= 1) sps_long_term_ref_pics_present_flag[NB_MAX_SPS];
	uint(size= 1) sps_temporal_mvp_enable_flag[NB_MAX_SPS];
	bool          sps_strong_intra_smoothing_enable_flag[NB_MAX_SPS];
	uint(size= 6) sps_num_long_term_ref_pics_sps[NB_MAX_SPS];
	uint(size=16) lt_ref_pic_poc_lsb_sps[32];
	uint(size= 8) used_by_curr_pic_lt_sps_flag[32];

	read_SPS_Header.se_idx_8 : action ==>
	guard
		se_idx = 8 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
			vld_u_name(1, fifo, res,
			"long_term_ref_pics_present_flag         ");
		sps_long_term_ref_pics_present_flag[sps_id] := res[0];
		if res[0] = 1 then
				vld_ue_name(fifo, res,
				"num_long_term_ref_pics_sps              ");
			sps_num_long_term_ref_pics_sps[sps_id] := res[0];
				foreach int i in 0 .. sps_num_long_term_ref_pics_sps[sps_id] - 1
				do
					vld_u_name(sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4,
					fifo, res, "lt_ref_pic_poc_lsb_sps                  ");
				lt_ref_pic_poc_lsb_sps[i] := res[0];
					vld_u_name(1, fifo, res,
					"used_by_curr_pic_lt_sps_flag            ");
				used_by_curr_pic_lt_sps_flag[i] := res[0];
			end
		end
			vld_u_name(1, fifo, res,
			"sps_temporal_mvp_enable_flag            ");
		sps_temporal_mvp_enable_flag[sps_id] := res[0];
			vld_u_name(1, fifo, res,
			"sps_strong_intra_smoothing_enable_flag  ");
		sps_strong_intra_smoothing_enable_flag[sps_id] := res[0] = 1;
			vld_u_name(1, fifo, res,
			"vui_parameters_present_flag             ");
		if res[0] = 1 then
			println("not support for vui_parameters_present_flag != 0");
		end
		se_idx := se_idx + 1;
	end

	/**************************************************************************
	 * read_SPS_Header_done
	 *************************************************************************/
	read_SPS_Header_done : action ==>
	guard
		se_idx = 9 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
			vld_u_name(1, fifo, res,
			"sps_extension_flag                      ");
		if res[0] = 1 then
			println("not support for sps_extension_flag != 0");
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER         *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_PPS_Header.se_idx_1
	 *************************************************************************/
	uint(size= 8) pps_sps_id[NB_MAX_PPS];
	uint(size= 2) pps_tiles_enabled_flag[NB_MAX_PPS];

	read_PPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
	    	
		vld_ue_name(    fifo, res, "pps_pic_parameter_set_id                ");
		pps_id := res[0];
		vld_ue_name(    fifo, res, "pps_seq_parameter_set_id                ");
		sps_id := res[0];
		pps_sps_id[pps_id] := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	        //pps_loop_filter_across_tiles_enabled_flag[pps_id] := 1;
    		pps_num_tile_columns_minus1[pps_id]       := 0;
    		pps_num_tile_rows_minus1[pps_id]          := 0;
    		pps_uniform_spacing_flag[pps_id]          := 1;
	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_2
	 *************************************************************************/
	uint(size= 1) pps_dependent_slice_segments_enabled_flag[NB_MAX_PPS];
	uint(size= 1) pps_output_flag_present_flag[NB_MAX_PPS];
	uint(size= 3) pps_num_extra_slice_header_bits[NB_MAX_PPS];
	uint(size= 1) pps_sign_data_hiding_flag[NB_MAX_PPS];
	uint(size= 1) pps_cabac_init_present_flag[NB_MAX_PPS];
	uint(size= 8) pps_num_ref_idx_l0_default_active_minus1[NB_MAX_PPS];
	uint(size= 8) pps_num_ref_idx_l1_default_active_minus1[NB_MAX_PPS];
	 int(size=32) pps_init_qp_minus26[NB_MAX_PPS];
	uint(size= 1) pps_transform_skip_enabled_flag[NB_MAX_PPS];
	bool          pps_constrained_intra_pred_flag[NB_MAX_PPS];
	uint(size= 1) pps_cu_qp_delta_enabled_flag[NB_MAX_PPS];
	uint(size=16) pps_diff_cu_qp_delta_depth[NB_MAX_PPS];
	 int(size= 8) pps_cb_qp_offset[NB_MAX_PPS];
	 int(size= 8) pps_cr_qp_offset[NB_MAX_PPS];
	uint(size= 1) pps_slice_chroma_qp_offsets_present_flag[NB_MAX_PPS];
	uint(size= 1) pps_weighted_pred_flag[NB_MAX_PPS];
	uint(size= 1) pps_weighted_bipred_flag[NB_MAX_PPS];
	uint(size= 1) pps_transquant_bypass_enable_flag[NB_MAX_PPS];
	uint(size= 1) pps_entropy_coding_sync_enabled_flag[NB_MAX_PPS];
	uint(size= 8) pps_num_tile_columns_minus1[NB_MAX_PPS];
	uint(size= 8) pps_num_tile_rows_minus1[NB_MAX_PPS];
	uint(size= 1) pps_uniform_spacing_flag[NB_MAX_PPS];

	read_PPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "dependent_slice_segments_enabled_flag   ");
		pps_dependent_slice_segments_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "output_flag_present_flag                ");
		pps_output_flag_present_flag[pps_id]:=res[0];
		vld_u_name(  3, fifo, res, "num_extra_slice_header_bits             ");
		pps_num_extra_slice_header_bits[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "sign_data_hiding_flag                   ");
		pps_sign_data_hiding_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "cabac_init_present_flag                 ");
		pps_cabac_init_present_flag[pps_id] := res[0];
		vld_ue_name(    fifo, res, "num_ref_idx_l0_default_active_minus1    ");
		pps_num_ref_idx_l0_default_active_minus1[pps_id] := res[0];
		vld_ue_name(    fifo, res, "num_ref_idx_l1_default_active_minus1    ");
		pps_num_ref_idx_l1_default_active_minus1[pps_id] := res[0];
		vld_se_name(    fifo, res, "init_qp_minus26                         ");
		pps_init_qp_minus26[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "constrained_intra_pred_flag             ");
		pps_constrained_intra_pred_flag[pps_id] := res[0] != 0;
		vld_u_name(  1, fifo, res, "transform_skip_enabled_flag             ");
		pps_transform_skip_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "cu_qp_delta_enabled_flag                ");
		pps_cu_qp_delta_enabled_flag[pps_id] := res[0];
		if res[0] = 1 then
			vld_ue_name(    fifo, res, "diff_cu_qp_delta_depth                  ");
			pps_diff_cu_qp_delta_depth[pps_id] := res[0];
		else
			pps_diff_cu_qp_delta_depth[pps_id] := 0;
		end
		vld_se_name(    fifo, res, "pps_cb_qp_offset                        ");
		pps_cb_qp_offset[pps_id] := res[0];
		vld_se_name(    fifo, res, "pps_cr_qp_offset                        ");
		pps_cr_qp_offset[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "pps_slice_chroma_qp_offsets_present_flag");
		pps_slice_chroma_qp_offsets_present_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "weighted_pred_flag                      ");
		pps_weighted_pred_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "weighted_bipred_flag                    ");
		pps_weighted_bipred_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "transquant_bypass_enable_flag           ");
		pps_transquant_bypass_enable_flag[pps_id]:=res[0];
		vld_u_name(  1, fifo, res, "tiles_enabled_flag                      ");
		pps_tiles_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "entropy_coding_sync_enabled_flag        ");
		pps_entropy_coding_sync_enabled_flag[pps_id] := res[0];
		pps_num_tile_columns_minus1[pps_id] := 0;
		pps_num_tile_rows_minus1[pps_id]    := 0;
		pps_uniform_spacing_flag[pps_id]    := 1;
		if pps_tiles_enabled_flag[pps_id] = 1 then
			vld_ue_name(    fifo, res, "num_tile_columns_minus1                 ");
			pps_num_tile_columns_minus1[pps_id] := res[0];
			vld_ue_name(    fifo, res, "num_tile_rows_minus1                    ");
			pps_num_tile_rows_minus1[pps_id] := res[0];
			vld_u_name ( 1, fifo, res, "uniform_spacing_flag                    ");
			pps_uniform_spacing_flag[pps_id] :=res[0];
		end
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_3
	 *************************************************************************/
	uint(size=16) pps_column_width[NB_MAX_PPS][PICT_WIDTH / MIN_CTB_SIZE_Y];

	read_PPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3  and isFifoFull(fifo),
	        pps_uniform_spacing_flag[pps_id] = 0 and cnt_i < pps_num_tile_columns_minus1[pps_id]
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "column_width[ ]                         ");
		pps_column_width[pps_id][cnt_i] := res[0] + 1;
	        sum := sum + pps_column_width[pps_id][cnt_i];
		if cnt_i >= (PICT_WIDTH / MIN_CTB_SIZE_Y) then
			println("Error read_PPS_Header.se_idx_3.loop : "+cnt_i+" >= "+(PICT_WIDTH / MIN_CTB_SIZE_Y));
		end
		cnt_i := cnt_i + 1;
	end
	read_PPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3,
	        pps_uniform_spacing_flag[pps_id] = 0 and cnt_i = pps_num_tile_columns_minus1[pps_id] 
	do
	    	pps_column_width[pps_id][pps_num_tile_columns_minus1[pps_id]] := sps_ctb_width[sps_id] - sum;
		se_idx := se_idx + 1;
		cnt_i  := 0;
	        sum := 0;
	end
	read_PPS_Header.se_idx_3.noLoop : action ==>
	guard
		se_idx = 3,
		pps_uniform_spacing_flag[pps_id] = 1
	do
		se_idx := se_idx + 2;
	end
	/**************************************************************************
	 * read_PPS_Header.se_idx4
	 *************************************************************************/
	uint(size=16) pps_row_height[NB_MAX_PPS][PICT_HEIGHT / MIN_CTB_SIZE_Y];
	uint(size= 1) pps_scaling_list_data_present_flag[NB_MAX_PPS];
	    int sum := 0;

	read_PPS_Header.se_idx_4.loop : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
	        pps_uniform_spacing_flag[pps_id] = 0 and cnt_i < pps_num_tile_rows_minus1[pps_id] 
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "row_height[ ]                           ");
		pps_row_height[pps_id][cnt_i] := res[0] + 1;
	        sum := sum + pps_row_height[pps_id][cnt_i];
		if cnt_i >= (PICT_HEIGHT / MIN_CTB_SIZE_Y) then
			println("Error read_PPS_Header.se_idx_4.loop : "+cnt_i+" >= "+(PICT_HEIGHT / MIN_CTB_SIZE_Y));
		end
		cnt_i := cnt_i + 1;
	end
	read_PPS_Header.se_idx_4.loopEnd : action ==>
	guard
		se_idx = 4,
	        pps_uniform_spacing_flag[pps_id] = 0 and cnt_i = pps_num_tile_rows_minus1[pps_id] 
	do
	    	pps_row_height[pps_id][pps_num_tile_rows_minus1[pps_id]] := sps_ctb_height[sps_id] - sum;
		cnt_i  := 0;
		se_idx := 5;
	        sum := 0;
	end

	read_PPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		if (pps_tiles_enabled_flag[pps_id] = 1) then
			vld_u_name(  1, fifo, res, "loop_filter_across_tiles_enabled_flag   ");
			//pps_loop_filter_across_tile_enabled_flag[pps_id] := res[0];
		end
		vld_u_name(  1, fifo, res, "loop_filter_across_slices_enabled_flag  ");
		pps_loop_filter_across_slice_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "deblocking_filter_control_present_flag  ");
		pps_deblocking_filter_control_present_flag[pps_id] := res[0];
		deblocking_filter_override_enabled_flag[pps_id] := 0;
		if pps_deblocking_filter_control_present_flag[pps_id] = 1 then
			vld_u_name(  1, fifo, res, "deblocking_filter_override_enabled_flag ");
			deblocking_filter_override_enabled_flag[pps_id] := res[0];
			vld_u_name(  1, fifo, res, "pps_disable_deblocking_filter_flag      ");
			pps_disable_deblocking_filter_flag[pps_id] := res[0];
			if res[0] = 0 then
				vld_se_name(    fifo, res, "pps_beta_offset_div2                    ");
				pps_beta_offset[pps_id] := res[0] << 1;
				vld_se_name(    fifo, res, "pps_tc_offset_div2                      ");
				pps_tc_offset[pps_id] := res[0] << 1;
			end
		end
		vld_u_name(  1, fifo, res, "pps_scaling_list_data_present_flag      ");
		pps_scaling_list_data_present_flag[pps_id] := res[0];
		if pps_scaling_list_data_present_flag[pps_id] = 0 then
			se_idx := 52;
		else
			se_idx := 50;
		end
	end

	/**************************************************************************
	 * read_PPS_Header.se_idx5
	 *************************************************************************/
	uint(size= 1) pps_deblocking_filter_control_present_flag[NB_MAX_PPS];
	uint(size =1) deblocking_filter_override_enabled_flag[NB_MAX_PPS];
	//uint(size= 1) pps_loop_filter_across_tile_enabled_flag[NB_MAX_PPS];
	uint(size= 1) pps_loop_filter_across_slice_enabled_flag[NB_MAX_PPS];
	uint(size= 1) pps_lists_modification_present_flag[NB_MAX_PPS];
	uint(size= 1) pps_slice_segment_header_extension_present_flag[NB_MAX_PPS];
	uint(size= 1) pps_disable_deblocking_filter_flag[NB_MAX_PPS];
	uint(size= 1) pps_beta_offset[NB_MAX_PPS];
	uint(size= 1) pps_tc_offset[NB_MAX_PPS];
	uint(size= 8) pps_log2_parallel_merge_level[NB_MAX_PPS];
	uint(size= 8) pps_sl[NB_MAX_PPS][4][6][64];
	uint(size= 8) pps_sl_dc[NB_MAX_PPS][2][6];
	int pps_matrix_id :=0;
	int pps_size_id := 0;
	int pps_next_coef;
	int pps_coef_num;
	int pps_scaling_list_delta_coef;
	int pps_pos;
	int pps_size_id_matrixCase;

	read_PPS_Header.se_idx_51 : action ==>
	guard
		se_idx = 52 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "lists_modification_present_flag         ");
		pps_lists_modification_present_flag[pps_id] := res[0];
		vld_ue_name(    fifo, res, "log2_parallel_merge_level_minus2        ");
		pps_log2_parallel_merge_level[pps_id] := res[0] + 2;
		vld_u_name(  1, fifo, res, "slice_segment_header_extension_present_flag");
		pps_slice_segment_header_extension_present_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "pps_extension_flag                      ");
		if res[0] = 1 then
			println("not support for pps_extension_flag != 0");
		end
		se_idx := 6;
	end

	read_PPS_Header.se_idx_50 : action ==>
	guard
		se_idx = 50 and isFifoFull(fifo)
	do
		foreach int matrixId in 0 .. 5 do
			// 4x4 default is 16
			foreach int i in 0 .. 15 do
				pps_sl[pps_id][0][matrixId][i] := 16;
			end
			pps_sl_dc[pps_id][0][matrixId] := 16; // default for 16x16
			pps_sl_dc[pps_id][1][matrixId] := 16; // default for 32x32
		end
		foreach int i in 0 .. 63 do
			pps_sl[pps_id][1][0][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][1][1][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][1][2][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][1][3][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][1][4][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][1][5][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][2][0][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][2][1][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][2][2][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][2][3][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][2][4][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][2][5][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][3][0][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][3][1][i] := default_scaling_list_inter[i];
		end
		se_idx := 51;
	end

	read_PPS_Header.se_idx_51_loopSize_id : action ==>
	guard
		se_idx = 51 and isFifoFull(fifo) , pps_size_id < 4
	do
		if pps_size_id = 3 then pps_size_id_matrixCase := 2; else pps_size_id_matrixCase := 6; end
		se_idx := 53;
	end

	read_PPS_Header.se_idx_53_loopMatrix_id: action ==>
	guard
		se_idx = 53 and isFifoFull(fifo) , pps_matrix_id < pps_size_id_matrixCase
	var
		uint(size=32) res[1],
		int delta,
		int size_id_memcpyCase,
		uint(size= 8) pps_scaling_list_pred_mode_flag[4][6],
		uint(size= 32) pps_scaling_list_dc_coef[2][6]
	do
		vld_u_name(  1, fifo, res, "scaling_list_pred_mode_flag             ");
		pps_scaling_list_pred_mode_flag[pps_size_id][pps_matrix_id] := res[0];
		if pps_scaling_list_pred_mode_flag[pps_size_id][pps_matrix_id] = 0 then
			vld_ue_name(    fifo, res, "delta                                   ");
				delta := res[0]; // Only need to handle non-zero delta. Zero means default, which should already be in the arrays.
				if delta != 0 then // Copy from previous array.
				if (pps_matrix_id - delta < 0) then
					println("Invalid delta in scaling list data");
				end
					if pps_size_id > 0 then
						size_id_memcpyCase := 64;
					else
						size_id_memcpyCase := 16;
					end
				foreach int k in 0 .. size_id_memcpyCase do
						pps_sl[pps_id][pps_size_id][pps_matrix_id][k] :=
						pps_sl[pps_id][pps_size_id][pps_matrix_id - delta][k];
				end
				if (pps_size_id > 1) then
						pps_sl_dc[pps_id][pps_size_id - 2][pps_matrix_id] :=
						pps_sl_dc[pps_id][pps_size_id - 2][pps_matrix_id - delta];
				end
			end
			pps_matrix_id := pps_matrix_id + 1;
		else
			pps_next_coef := 8;
			pps_coef_num := min(64, (1  <<  (4 + (pps_size_id  <<  1))));
			if (pps_size_id > 1) then
				vld_se_name(    fifo, res, "scaling_list_dc_coef                    ");
				pps_scaling_list_dc_coef[pps_size_id - 2][pps_matrix_id] := res[0] + 8;
					pps_next_coef := pps_scaling_list_dc_coef[pps_size_id -
					2][pps_matrix_id];
				pps_sl_dc[pps_id][pps_size_id - 2][pps_matrix_id] := pps_next_coef;
			end
			se_idx := 54;
			cnt_i := 0;
		end
	end

	read_PPS_Header.se_idx_54_loopNumCoef : action ==>
	guard
		se_idx = 54 and isFifoFull(fifo), cnt_i < pps_coef_num
	var
		uint(size=32) res[1]
	do
		if (pps_size_id = 0) then
			pps_pos := 4 * hevc_diag_scan4x4_y[cnt_i] + hevc_diag_scan4x4_x[cnt_i];
		else
			pps_pos := 8 * hevc_diag_scan8x8_y[cnt_i] + hevc_diag_scan8x8_x[cnt_i];
		end
		vld_se_name(    fifo, res, "scaling_list_delta_coef                 ");
		pps_scaling_list_delta_coef := res[0];
		pps_next_coef := (pps_next_coef + pps_scaling_list_delta_coef + 256) & 255;
		pps_sl[pps_id][pps_size_id][pps_matrix_id][pps_pos] := pps_next_coef;
		cnt_i := cnt_i + 1;
	end

	read_PPS_Header.se_idx_54_loopNumCoefEnd : action ==>
	guard
		se_idx = 54 and isFifoFull(fifo), cnt_i = pps_coef_num
	do
		cnt_i := 0;
		pps_matrix_id := pps_matrix_id + 1;
		se_idx := 53;
	end


	read_PPS_Header.se_idx_53_loopMatrix_id_End : action ==>
	guard
		se_idx = 53 and isFifoFull(fifo) , pps_matrix_id = pps_size_id_matrixCase
	do
		pps_size_id := pps_size_id + 1;
		pps_matrix_id := 0;
		se_idx := 51;
	end

	read_PPS_Header.se_idx_51_loopSize_id_End : action ==>
	guard
		se_idx = 51 and isFifoFull(fifo) , pps_size_id = 4
	do
		pps_size_id := 0;
		se_idx := 52;
	end

	/**************************************************************************
	 * read_PPS_Header_done
	 *************************************************************************/
	read_PPS_Header_done : action ==>
	guard
		se_idx = 6
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Slice HEADER                         *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SliceHeader.se_idx_1
	 *************************************************************************/
	uint(size= 8) Log2CtbSize;
	uint(size= 8) Log2MinCbSize;
	uint(size=16) PicWidthInCtbsY;
	uint(size=16) PicHeightInCtbsY;
	uint(size=16) PicSizeInCtbsY;
	uint(size= 1) slice_temporal_mvp_enable_flag;

	int(size=32) poc;
	uint(size= 3) slice_type;
	uint(size=32) slice_segment_address;
	uint(size= 1) slice_sample_adaptive_offset_flag[4];

	procedure compute_POC(int pic_order_cnt_lsb)
	var
		 int iPOClsb = pic_order_cnt_lsb,
		 int iPrevPOC = poc,
		 int iMaxPOClsb := max_poc_lsb[sps_id],
		 int iPrevPOClsb,
		 int iPrevPOCmsb,
		 int iPOCmsb
	begin
		iPrevPOClsb := iPrevPOC mod iMaxPOClsb;
		iPrevPOCmsb := iPrevPOC-iPrevPOClsb;
		if( (iPOClsb < iPrevPOClsb) and ( (iPrevPOClsb - iPOClsb) >= (iMaxPOClsb / 2) ) ) then
			iPOCmsb := iPrevPOCmsb + iMaxPOClsb;
		else
			if( (iPOClsb > iPrevPOClsb)  and ( (iPOClsb - iPrevPOClsb) > (iMaxPOClsb / 2) ) ) then
				iPOCmsb := iPrevPOCmsb - iMaxPOClsb;
			else
				iPOCmsb := iPrevPOCmsb;
			end
		end
				if (nal_unit_type = NAL_BLA_W_LP   or
				nal_unit_type = NAL_BLA_W_RADL or
				nal_unit_type = NAL_BLA_N_LP)
		then
				iPOCmsb := 0;
		end

		poc:= iPOCmsb+iPOClsb;
	end

	uint(size= 1) first_slice_segment_in_pic_flag := 1;
	uint(size= 1) dependent_slice_segment_flag;
	uint(size=16) pictSize[2];
	uint(size=16) num_long_term_sps := 0;
	uint(size=16) num_long_term_pics := 0;
	uint(size= 8) poc_lsb_lt[32];
	uint(size= 8) UsedByCurrPicLt[32];
	uint(size= 8) DeltaPocMsbCycleLt[32];
	uint(size= 8) delta_poc_msb_present_flag[32];
	int pic_order_cnt_lsb;
	uint(size=16) pictOrTileSize[2] := [0,0];
	uint rowIndex := 0;
	uint colIndex := 0;
	uint(size=16) prevTileCoord[2] := [0,0];
	uint prevRowIndex := 0;
	uint prevColIndex := 0;
	uint slice_addr := 0;
	int slice_idx :=0;
	int idx := 0;
	uint no_output_of_prior_pics_flag;
	uint pic_output_flag;

	read_SliceHeader.se_idx_1 : action ==> PartMode:[part_mode]

	guard
			se_idx = 1 and idx = 0 and isFifoFull(fifo), bypassFlag = false
	var
		uint(size=32) res[1],
		uint(size= 4) part_mode
	do

		Log2MinCbSize     := sps_log2_min_coding_block_size[sps_id] ;
		Log2CtbSize       := Log2MinCbSize + sps_log2_diff_max_min_coding_block_size[sps_id];
		PicWidthInCtbsY   := ( sps_pic_width_in_luma_samples[sps_id]  + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
		PicHeightInCtbsY  := ( sps_pic_height_in_luma_samples[sps_id] + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
		PicSizeInCtbsY    := PicWidthInCtbsY * PicHeightInCtbsY;

		TilesInfo := [TILE_SPLIT_ENABLE, TILE_INDEX];

		vld_u_name(  1, fifo, res, "first_slice_segment_in_pic_flag         ");
		first_slice_segment_in_pic_flag := res[0];

		no_output_of_prior_pics_flag := 0;
		if nal_unit_type >= 16 and nal_unit_type <= 23 then
			vld_u_name(  1, fifo, res, "no_output_of_prior_pics_flag            ");
			no_output_of_prior_pics_flag := res[0];
		end
//		if nal_unit_type = NAL_CRA_NUT and last_eos = 1 then
//			no_output_of_prior_pics_flag := 1;
//		end
		vld_ue_name(    fifo, res, "slice_pic_parameter_set_id              ");
		pps_id := res[0];
		sps_id := pps_sps_id[pps_id];
		dependent_slice_segment_flag := 0;

		if first_slice_segment_in_pic_flag = 0 then
			if (pps_dependent_slice_segments_enabled_flag[pps_id] = 1) then
				vld_u_name(  1, fifo, res, "dependent_slice_segment_flag                    ");
				dependent_slice_segment_flag := res[0];
			end
			vld_u_name(log2((PicSizeInCtbsY-1)<<1) , fifo, res, "slice_segment_address                   ");
			slice_segment_address := res[0];
			if (dependent_slice_segment_flag = 0) then
					slice_addr := slice_segment_address;
				slice_idx := slice_idx + 1;
			end
		else
			slice_segment_address := 0;
				slice_addr := 0;
		end

			pictSize[0] := sps_pic_width_in_luma_samples[sps_id];
			pictSize[1] := sps_pic_height_in_luma_samples[sps_id];

		if first_slice_segment_in_pic_flag = 1 then
			part_mode := PART_MODE_PICT;
		elsif dependent_slice_segment_flag = 0 then
			part_mode := PART_MODE_SLICE_INDEP;
		else
			part_mode := PART_MODE_SLICE_DEP;
		end
		if dependent_slice_segment_flag = 0 then
				se_idx := 200;
			else
				se_idx := 6;
			end
		end
		
	read_SliceHeader.se_idx_1_bypass : action ==> 
	guard
			se_idx = 1 and idx = 0 and isFifoFull(fifo), bypassFlag = true
	var
		uint(size=32) res[1]
	do

		Log2MinCbSize     := sps_log2_min_coding_block_size[sps_id] ;
		Log2CtbSize       := Log2MinCbSize + sps_log2_diff_max_min_coding_block_size[sps_id];
		PicWidthInCtbsY   := ( sps_pic_width_in_luma_samples[sps_id]  + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
		PicHeightInCtbsY  := ( sps_pic_height_in_luma_samples[sps_id] + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
		PicSizeInCtbsY    := PicWidthInCtbsY * PicHeightInCtbsY;

		TilesInfo := [TILE_SPLIT_ENABLE, TILE_INDEX];

		vld_u_name(  1, fifo, res, "first_slice_segment_in_pic_flag         ");
		first_slice_segment_in_pic_flag := res[0];

		no_output_of_prior_pics_flag := 0;
		if nal_unit_type >= 16 and nal_unit_type <= 23 then
			vld_u_name(  1, fifo, res, "no_output_of_prior_pics_flag            ");
			no_output_of_prior_pics_flag := res[0];
		end
//		if nal_unit_type = NAL_CRA_NUT and last_eos = 1 then
//			no_output_of_prior_pics_flag := 1;
//		end
		vld_ue_name(    fifo, res, "slice_pic_parameter_set_id              ");
		pps_id := res[0];
		sps_id := pps_sps_id[pps_id];
		dependent_slice_segment_flag := 0;

		if first_slice_segment_in_pic_flag = 0 then
			if (pps_dependent_slice_segments_enabled_flag[pps_id] = 1) then
				vld_u_name(  1, fifo, res, "dependent_slice_segment_flag                    ");
				dependent_slice_segment_flag := res[0];
			end
			vld_u_name(log2((PicSizeInCtbsY-1)<<1) , fifo, res, "slice_segment_address                   ");
			slice_segment_address := res[0];
			if (dependent_slice_segment_flag = 0) then
					slice_addr := slice_segment_address;
				slice_idx := slice_idx + 1;
			end
		else
			slice_segment_address := 0;
				slice_addr := 0;
		end

		pictSize[0] := sps_pic_width_in_luma_samples[sps_id];
		pictSize[1] := sps_pic_height_in_luma_samples[sps_id];

		if dependent_slice_segment_flag = 0 then
				se_idx := 200;
			else
				se_idx := 6;
			end
		end
		
	    read_SliceHeader.se_idx_11 : action ==> Poc:[poc], SliceType:[slice_type], LcuSizeMax:[Log2CtbSize]
		guard
				se_idx = 200 and isFifoFull(fifo), bypassFlag = false
		var
			uint(size=32) res[1],
	        uint(size= 8) numbits := 0
		do
			foreach int i in 0 .. pps_num_extra_slice_header_bits[pps_id] - 1 do
				vld_u_name(  1, fifo, res, "slice_reserved_undetermined_flag[i]     ");
			end
			vld_ue_name(    fifo, res, "slice_type                              ");
			slice_type := res[0];

			slice_temporal_mvp_enable_flag := 0;
			idx := 0;
			pic_output_flag := 1;
			if(pps_output_flag_present_flag[pps_id] = 1) then
				vld_u_name(  1, fifo, res, "pic_output_flag                         ");
				pic_output_flag := res[0];
			end
			if sps_separate_colour_plane_flag[sps_id] = 1 then
				vld_u_name(  2, fifo, res, "colour_plane_id                         ");
			end

			if nal_unit_type = NAL_IDR_W_DLP or nal_unit_type = NAL_IDR_N_LP then
				poc := 0;
	        	se_idx := 302;
				//sps_num_short_term_ref_pic_sets[sps_id] := 0;
			else
				vld_u_name( sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifo, res, "pic_order_cnt_lsb                       ");
				pic_order_cnt_lsb := res[0];
				//compute the number of POC
				compute_POC(res[0]);
				vld_u_name(  1, fifo, res, "short_term_ref_pic_set_sps_flag         ");
	            short_term_ref_pic_set_sps_flag := res[0];
	            if short_term_ref_pic_set_sps_flag != 0 then
					while ((1 << numbits) < sps_num_short_term_ref_pic_sets[sps_id]) do
						numbits := numbits + 1;
					end
					res[0] := 0;
					if (numbits > 0) then
						vld_u_name(   numbits, fifo, res, "short_term_ref_pic_set_idx              ");
					end
					pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]] := [pcRPS[sps_id][res[0]][i] : for int i in 0 .. PC_RPS_STRUCT_SIZE - 1];
	                se_idx := 301;
	       		else
	    			se_idx := 300;
	    		end
	    	end
		end
		
		read_SliceHeader.se_idx_11_bypass : action ==> 
		guard
				se_idx = 200 and isFifoFull(fifo), bypassFlag = true
		var
			uint(size=32) res[1],
	        uint(size= 8) numbits := 0
		do
			foreach int i in 0 .. pps_num_extra_slice_header_bits[pps_id] - 1 do
				vld_u_name(  1, fifo, res, "slice_reserved_undetermined_flag[i]     ");
			end
			vld_ue_name(    fifo, res, "slice_type                              ");
			slice_type := res[0];

			slice_temporal_mvp_enable_flag := 0;
			idx := 0;
			pic_output_flag := 1;
			if(pps_output_flag_present_flag[pps_id] = 1) then
				vld_u_name(  1, fifo, res, "pic_output_flag                         ");
				pic_output_flag := res[0];
			end
			if sps_separate_colour_plane_flag[sps_id] = 1 then
				vld_u_name(  2, fifo, res, "colour_plane_id                         ");
			end

			if nal_unit_type = NAL_IDR_W_DLP or nal_unit_type = NAL_IDR_N_LP then
				poc := 0;
	        	se_idx := 302;
				//sps_num_short_term_ref_pic_sets[sps_id] := 0;
			else
				vld_u_name( sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifo, res, "pic_order_cnt_lsb                       ");
				pic_order_cnt_lsb := res[0];
				//compute the number of POC
				compute_POC(res[0]);
				vld_u_name(  1, fifo, res, "short_term_ref_pic_set_sps_flag         ");
	            short_term_ref_pic_set_sps_flag := res[0];
	            if short_term_ref_pic_set_sps_flag != 0 then
					while ((1 << numbits) < sps_num_short_term_ref_pic_sets[sps_id]) do
						numbits := numbits + 1;
					end
					res[0] := 0;
					if (numbits > 0) then
						vld_u_name(   numbits, fifo, res, "short_term_ref_pic_set_idx              ");
					end
					pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]] := [pcRPS[sps_id][res[0]][i] : for int i in 0 .. PC_RPS_STRUCT_SIZE - 1];
	                se_idx := 301;
	       		else
	    			se_idx := 300;
	    		end
	    	end
		end
		
		uint(size=1) short_term_ref_pic_set_sps_flag;
		int(size=32) prev;
	                
		read_SliceHeader.se_idx_12 : action ==> //split of parseShortTermRefPicSet(sps_id, sps_num_short_term_ref_pic_sets[sps_id], sps_num_short_term_ref_pic_sets[sps_id], fifo, pcRPS);
		guard
			se_idx = 300 and isFifoFull(fifo)
	    var
			uint(size=32) res[1],
			uint(size= 1) inter_rps_flag := 0,
			uint(size=16) delta_idx      := 1,
			uint(size= 8) rIdx,
			 int(size=32) deltaRPS,
			 int(size=32) deltaPOC,
			 int(size=32) k    := 0,
			 int(size=32) k0   := 0,
			 int(size=32) k1   := 0,
			 int(size=32) delta_rps_sign,
			 int(size=32) abs_delta_rps
   		do
   			prev := 0;
   			cnt_i := 0;
	   		se_idx := 301;
	 		if (sps_num_short_term_ref_pic_sets[sps_id] != 0) then
	 			vld_u_name(  1, fifo, res, "inter_ref_pic_set_prediction_flag       "); inter_rps_flag := res[0];
	 		end
			if inter_rps_flag = 1 then
				//if idx = idx then
	  			vld_ue_name(    fifo, res, "delta_idx_minus1                        "); delta_idx := res[0] + 1;
	  			//end
	    		rIdx := sps_num_short_term_ref_pic_sets[sps_id] - delta_idx;
	    		vld_u_name(  1, fifo, res, "delta_rps_sign                          "); delta_rps_sign	:= res[0];
	    		vld_ue_name(    fifo, res, "abs_delta_rps_minus1                    "); abs_delta_rps	:= res[0] + 1;
	    		deltaRPS := (1 - (delta_rps_sign<<1)) * (abs_delta_rps);
	    		foreach uint(size=8) i in 0 ..  pcRPS[sps_id][rIdx][NUM_PICS] do
	    			vld_u_name(  1, fifo, res, "used_by_curr_pic_flag                   ");
	    			if res[0] = 0 then
		    			vld_u_name(  1, fifo, res, "use_delta_flag                          ");
		    			res[0] := res[0] << 1;
	    			end
	    			if res[0] = 1 or res[0] = 2 then
	    				if i < pcRPS[sps_id][rIdx][NUM_PICS] then
	    					deltaPOC := deltaRPS + pcRPS[sps_id][rIdx][DELTAPOC+i];
	    				else
	    					deltaPOC := deltaRPS;
						end
						pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][DELTAPOC+k] := deltaPOC;
						pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED+k] := if res[0] = 1 then 1 else 0 end;
				        if deltaPOC < 0 then
	          				k0 := k0 + 1;
	        			else 
	          				k1 := k1 + 1;
	        			end
	        			k := k + 1; 			
				end
	    		end
	    		pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_PICS]          := k;
	    		pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS] := k0;
				pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_POSITIVE_PICS] := k1;
				sortDeltaPOC(sps_id, sps_num_short_term_ref_pic_sets[sps_id], pcRPS);
	  		else
	    		vld_ue_name(    fifo, res, "num_negative_pics                       ");
	    		pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS] := res[0];
	    		vld_ue_name(    fifo, res, "num_positive_pics                       ");
	    		pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_POSITIVE_PICS] := res[0];
	    		pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_PICS] := pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS] + res[0];
	    		if pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS] != 0 then
	    			se_idx := 310;
	    		else
	    			prev := 0;
					if pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_POSITIVE_PICS] != 0 then
						se_idx := 320;
						cnt_i := pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS];
					end
	    		end
	    	end
	    end
	    
	    read_SliceHeader.se_idx_12_loop1: action ==> 
	    guard
	    	se_idx = 310 and isFifoFull(fifo),
	    	cnt_i < pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS]
	    var
	    	uint(size=32) res[1]
	    do    	
			vld_ue_name(    fifo, res, "delta_poc_s0_minus1                     ");
			prev := prev-res[0]-1;
			pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][DELTAPOC+cnt_i] := prev;
			vld_u_name(  1, fifo, res, "used_by_curr_pic_s0_flag                ");
			pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED+cnt_i]       := res[0];
			cnt_i := cnt_i + 1;
		end
		
		read_SliceHeader.se_idx_12_end_loop1: action ==> 
	    guard
	    	se_idx = 310, cnt_i = pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS]
	    do
	    	
	    	if pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_POSITIVE_PICS] != 0 then
	    		se_idx := 320;
	    		prev := 0;
	    	else
	    		se_idx := 301;
	    		cnt_i := 0;
	    	end
	    end
	    
	    read_SliceHeader.se_idx_12_loop2: action ==> 
	    guard
	    	se_idx = 320 and isFifoFull(fifo),
	    	cnt_i < pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_PICS] 
	    var
	    	uint(size=32) res[1]
	    do
			vld_ue_name(    fifo, res, "delta_poc_s1_minus1                     ");
			prev := prev+res[0]+1;
			pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][DELTAPOC+cnt_i] := prev;
			vld_u_name(  1, fifo, res, "used_by_curr_pic_s1_flag                ");
			pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED+cnt_i]       := res[0];
			cnt_i := cnt_i + 1;
		end
		
		read_SliceHeader.se_idx_12_end_loop2: action ==> 
	    guard
	    	se_idx = 320, cnt_i = pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_PICS]
	    do
    		se_idx := 301;
    		cnt_i := 0;
	    end
		
		read_SliceHeader.se_idx_13 : action ==> 
		guard
			se_idx = 301 and isFifoFull(fifo)
		 var
	        uint(size=32) res[1],
	        uint(size= 8) lt_idx_sps := 0,
	        uint(size= 8) prevDeltaMSB := 0
		do
				num_long_term_sps := 0;
				num_long_term_pics := 0;

				if sps_long_term_ref_pics_present_flag[sps_id] = 1 then
					if sps_num_long_term_ref_pics_sps[sps_id] > 0 then
						vld_ue_name(    fifo, res, "num_long_term_sps                       ");
						num_long_term_sps := res[0];
					end
					vld_ue_name(    fifo, res, "num_long_term_pics                      ");
					num_long_term_pics := res[0];
					foreach int i in 0 .. num_long_term_sps + num_long_term_pics - 1 do
						if i < num_long_term_sps then
							if num_long_term_pics > 1 then
								vld_u_name(log2((PicSizeInCtbsY-1)<<1) , fifo, res, "lt_idx_sps                              ");
								lt_idx_sps := res[0];
							end
							poc_lsb_lt[i] := lt_ref_pic_poc_lsb_sps[lt_idx_sps];
							UsedByCurrPicLt[i] := used_by_curr_pic_lt_sps_flag[lt_idx_sps];
						else
							vld_u_name( sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifo, res, "poc_lsb_lt                              ");
							poc_lsb_lt[i] := res[0];
							vld_u_name(  1, fifo, res, "used_by_curr_pic_lt_flag                ");
							UsedByCurrPicLt[i] :=  res[0];
						end
						vld_u_name(  1, fifo, res, "delta_poc_msb_present_flag              ");
						delta_poc_msb_present_flag[i] := res[0];
						if res[0] = 1 then
							if( i = 0 or i = num_long_term_sps ) then
								vld_ue_name(    fifo, res, "delta_poc_msb_cycle_lt_minus1                ");
								DeltaPocMsbCycleLt[i] := res[0];
							else
								vld_ue_name(    fifo, res, "delta_poc_msb_cycle_lt_minus1                ");
								DeltaPocMsbCycleLt[i] := res[0] + prevDeltaMSB;
							end
							prevDeltaMSB := DeltaPocMsbCycleLt[i];
						end
					end
				end
				if sps_temporal_mvp_enable_flag[sps_id] = 1 then
					vld_u_name(  1, fifo, res, "slice_temporal_mvp_enable_flag          ");
					slice_temporal_mvp_enable_flag := res[0];
				else
					slice_temporal_mvp_enable_flag := 0;
				end
	        se_idx := 302;
			end

		read_SliceHeader.se_idx_14 : action  ==> 
		guard
			se_idx = 302 and isFifoFull(fifo)
		var
			uint(size=32) res[1],
			uint(size=16) column_width[PICT_WIDTH / MIN_CTB_SIZE_Y]= [pps_column_width[pps_id][ i ] : for int i in 0 .. (PICT_WIDTH / MIN_CTB_SIZE_Y)-1],
		    uint(size=16) row_height[PICT_HEIGHT / MIN_CTB_SIZE_Y]  = [pps_row_height[pps_id][ i ] : for int i in 0 .. (PICT_HEIGHT / MIN_CTB_SIZE_Y)-1],
		    uint(size= 8) num_tile_columns_minus1           = pps_num_tile_columns_minus1[pps_id],
		    uint(size= 8) num_tile_rows_minus1                      = pps_num_tile_rows_minus1[pps_id],
		    uint(size= 1) uniform_spacing_flag                      = pps_uniform_spacing_flag[pps_id]
		do
			if (temporal_id = 0 and nal_unit_type != NAL_TRAIL_N and
				nal_unit_type != NAL_TSA_N   and
				nal_unit_type != NAL_STSA_N  and
				nal_unit_type != NAL_RADL_N  and
				nal_unit_type != NAL_RADL_R  and
				nal_unit_type != NAL_RASL_N  and
				nal_unit_type != NAL_RASL_R) then
			end

			if( sps_sample_adaptive_offset_enabled_flag[sps_id] = 1) then
				vld_u_name(  1, fifo, res, "slice_sao_luma_flag                     ");
				slice_sample_adaptive_offset_flag[0] := res[0];
				vld_u_name(  1, fifo, res, "slice_sao_chroma_flag                   ");
				slice_sample_adaptive_offset_flag[1] := res[0];
				slice_sample_adaptive_offset_flag[2] := res[0];
						else
								slice_sample_adaptive_offset_flag[0] := 0;
						slice_sample_adaptive_offset_flag[1] := 0;
						slice_sample_adaptive_offset_flag[2] := 0;
			end

		//////////////////////////////////////////////////////////////////////////// copied from line 2412
		if num_tile_columns_minus1 >= (PICT_WIDTH / MIN_CTB_SIZE_Y) then
			println("Error read_SliceData.init : ColumnWidth : "+num_tile_columns_minus1+" >= "+(PICT_WIDTH / MIN_CTB_SIZE_Y));
		end
		if uniform_spacing_flag = 1 then
			foreach int i in 0 .. num_tile_columns_minus1 do
	                colWidth[pps_id][ i ] := ((i + 1)*PicWidthInCtbsY) / (num_tile_columns_minus1+1) - (i*PicWidthInCtbsY) / (num_tile_columns_minus1+1);
	                colTileInPix[ i + 1 ] :=   (colWidth[pps_id][ i ] << Log2CtbSize) + colTileInPix[ i ];
				if i = num_tile_columns_minus1 then
					colTileInPix[ i + 1 ] := pictSize [0];
				end
			end
		else
	            colWidth[pps_id][ num_tile_columns_minus1 ] := PicWidthInCtbsY;
	            if num_tile_columns_minus1 = 0 then
	            	colTileInPix[ 1 ] := pictSize [0];
	            else
			foreach int i in 0 .. num_tile_columns_minus1 - 1 do
		                colWidth[pps_id][ i ] := column_width[ i ] ;
		                colWidth[pps_id][ num_tile_columns_minus1 ] := colWidth[pps_id][ num_tile_columns_minus1 ] - colWidth[pps_id][ i ];
		                colTileInPix[ i + 1 ] :=   (colWidth[pps_id][ i ] << Log2CtbSize) + colTileInPix[ i ];
				if i = num_tile_columns_minus1 - 1 then
					colTileInPix[ i + 2 ] := pictSize [0];
				end
			end
		end
	        end

		if num_tile_rows_minus1 >= (PICT_HEIGHT / MIN_CTB_SIZE_Y) then
			println("Error read_SliceData.init : RowHeight : "+num_tile_rows_minus1+" >= "+(PICT_HEIGHT / MIN_CTB_SIZE_Y));
		end
		if uniform_spacing_flag = 1 then
			foreach int i in 0 .. num_tile_rows_minus1 do
	                rowHeight[pps_id][ i ] := ((i+1)*PicHeightInCtbsY) / (num_tile_rows_minus1+1) - (i*PicHeightInCtbsY) / (num_tile_rows_minus1+1);
	                rowTileInPix[ i + 1 ] :=   (rowHeight[pps_id][ i ] << Log2CtbSize) + rowTileInPix[ i ];
				if i = num_tile_rows_minus1 then
					rowTileInPix[ i + 1 ] := pictSize [1];
				end
			end
		else
	            rowHeight[pps_id][ num_tile_rows_minus1 ] := PicHeightInCtbsY;
	            if num_tile_rows_minus1 = 0 then
	            	rowTileInPix[ 1 ] := pictSize [1];
	            else 
			foreach int i in 0 .. num_tile_rows_minus1 - 1 do
		                rowHeight[pps_id][ i ] := row_height[ i ];
		                rowHeight[pps_id][ num_tile_rows_minus1 ] := rowHeight[pps_id][ num_tile_columns_minus1 ] - rowHeight[pps_id][ i ];
		                rowTileInPix[ i + 1 ] :=   (rowHeight[pps_id][ i ] << Log2CtbSize) + rowTileInPix[ i ];
				if i = num_tile_rows_minus1 - 1 then
					rowTileInPix[ i + 2 ] := pictSize [1];
				end
			end
		end
	        end
		if TILE_SPLIT_ENABLE = 0 then // no tiles split : send image size
			pictOrTileSize[0] := pictSize[0];
			pictOrTileSize[1] := pictSize[1];
		else // tiles split : send current tile size
			colIndex := TilesInfo[1]  mod (num_tile_columns_minus1+1);
			rowIndex := TilesInfo[1]  div (num_tile_columns_minus1+1);

			pictOrTileSize[0] := colTileInPix[colIndex + 1] - colTileInPix[colIndex];
			pictOrTileSize[1] := rowTileInPix[rowIndex + 1] - rowTileInPix[rowIndex];
			if TilesInfo[1] != 0 then
				prevColIndex := (TilesInfo[1] - 1)  mod (num_tile_rows_minus1+1);
				prevRowIndex := (TilesInfo[1] - 1)  div (num_tile_columns_minus1+1);
				prevTileCoord[0] := colTileInPix[prevColIndex + 1];
				prevTileCoord[1] := rowTileInPix[prevRowIndex + 1];
			end
		end
			se_idx := 2;
	end


	/**************************************************************************
	 * read_SliceHeader.se_idx_2
	 *************************************************************************/
	uint(size= 8) num_ref_idx_l0_active;
	uint(size= 8) num_ref_idx_l1_active;
	uint(size= 1) mvd_l1_zero_flag;
	uint(size= 8) ref_pic_list_modification_flag_lx[2] := [0,0];
	uint(size=4) list_entry_lx [2][32];

	read_SliceHeader.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		int NumPocTotalCurr := 0
	do
		num_ref_idx_l0_active    := 0;
		num_ref_idx_l1_active    := 0;
		mvd_l1_zero_flag         := 0;
		if slice_type = P_SLICE or slice_type = B_SLICE then
			num_ref_idx_l0_active := pps_num_ref_idx_l0_default_active_minus1[pps_id] + 1;
			if slice_type = B_SLICE then
				num_ref_idx_l1_active := pps_num_ref_idx_l1_default_active_minus1[pps_id] + 1;
			end
			vld_u_name(  1, fifo, res, "num_ref_idx_active_override_flag        ");
			if res[0] = 1 then
				vld_ue_name(    fifo, res, "num_ref_idx_l0_active_minus1            ");
				num_ref_idx_l0_active := res[0] + 1;
				if slice_type = B_SLICE then
					vld_ue_name(    fifo, res, "num_ref_idx_l1_active_minus1            ");
					num_ref_idx_l1_active := res[0] + 1;
				end
			end

			ref_pic_list_modification_flag_lx[0] := 0;
			ref_pic_list_modification_flag_lx[1] := 0;

                foreach int i in 0 ..
                pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS]- 1 do
                	if
                	(pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED + i] = 1) then
					NumPocTotalCurr := NumPocTotalCurr + 1;
				end
			end

			foreach int i in pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS] .. pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_PICS]-1 do
				if (pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED+i] = 1) then
					NumPocTotalCurr := NumPocTotalCurr + 1;
				end
			end

			foreach int i in 0 .. num_long_term_sps + num_long_term_pics - 1 do
				if ( UsedByCurrPicLt[i] = 1) then
					NumPocTotalCurr := NumPocTotalCurr + 1;
				end
			end

			if pps_lists_modification_present_flag[pps_id] = 1 and NumPocTotalCurr > 1 then
				vld_u_name(  1, fifo, res, "ref_pic_list_modification_flag_l0       ");
				ref_pic_list_modification_flag_lx[0] := res[0];
				if ref_pic_list_modification_flag_lx[0] = 1 then
					foreach int i in 0 .. num_ref_idx_l0_active - 1 do
						vld_u_name(log2((NumPocTotalCurr-1)<<1) , fifo, res, "list_entry_lx                           ");
						list_entry_lx[0][i] := res[0];
					end
				end

				if slice_type = B_SLICE then
					vld_u_name(  1, fifo, res, "ref_pic_list_modification_flag_l1       ");
					ref_pic_list_modification_flag_lx[1] := res[0];
					if ref_pic_list_modification_flag_lx[1] = 1 then
						foreach int i in 0 .. num_ref_idx_l1_active - 1 do
							vld_u_name(log2((NumPocTotalCurr-1)<<1) , fifo, res, "list_entry_lx                           ");
							list_entry_lx[1][i] := res[0];
						end
					end
				end
			end
			if slice_type = B_SLICE then
				vld_u_name(  1, fifo, res, "mvd_l1_zero_flag                        ");
				mvd_l1_zero_flag := res[0];
			end
		end
		se_idx := 10;
	end
	/**************************************************************************
	 * read_SliceHeader.sendRefPOC
	 *************************************************************************/
	int(size=16)  pocTables[5][NB_MAX_PICS];
	int numPic[5];
	uint(size= 8) idxNumPic;
	uint(size= 8) idxRefPoc;

	procedure setRefTables(int sps_id, int idx, int(size=8) pc_rps[NB_MAX_SPS][NB_MAX_PICS+1][PC_RPS_STRUCT_SIZE], int poc)
	var
		uint j := 0,
		uint k := 0,
		int pocLt := poc_lsb_lt[0]
	begin
		foreach int i in 0 .. pc_rps[sps_id][idx][NUM_NEGATIVE_PICS]-1
		do
			if(pc_rps[sps_id][idx][USED+i]=1) then
	            		pocTables[ST_CURR_BEF][j] := poc + pc_rps[sps_id][idx][DELTAPOC + i];
				j := j + 1;
	            		
			else
				pocTables[ST_FOLL][k] := poc + pc_rps[sps_id][idx][DELTAPOC+i];
				k := k + 1;
	            		
			end
		end
		numPic[ST_CURR_BEF] := j;
		j:=0;
		foreach int i in
				pc_rps[sps_id][idx][NUM_NEGATIVE_PICS] ..
				pc_rps[sps_id][idx][NUM_PICS] - 1 do
			if(pc_rps[sps_id][idx][USED+i]=1) then
                		pocTables[ST_CURR_AFT][j] := poc + pc_rps[sps_id][idx][DELTAPOC + i];
				j := j + 1;
                		
			else
				pocTables[ST_FOLL][k] := poc + pc_rps[sps_id][idx][DELTAPOC+i];
				k := k + 1;
			end
		end
		numPic[ST_CURR_AFT] := j;
		numPic[ST_FOLL] := k;
		j := 0;
		k := 0;
		foreach int i in 0 .. (num_long_term_sps +
				num_long_term_pics) - 1 do
			pocLt := poc_lsb_lt[i];
			if delta_poc_msb_present_flag[i] = 1 then
				pocLt := pocLt + poc - DeltaPocMsbCycleLt[i] * max_poc_lsb[sps_id] - pic_order_cnt_lsb;
			end
			if UsedByCurrPicLt[i] = 1 then
				pocTables[LT_CURR][j] := pocLt;
				j := j + 1;
			else
				pocTables[LT_FOLL][k] := pocLt;
				k := k + 1;
			end
		end
		numPic[LT_CURR] := j;
		numPic[LT_FOLL] := k;
	end

	read_SliceHeader.sendRefPOC.init : action ==> NumRefIdxLxActive:[num_ref_idx_l0_active, num_ref_idx_l1_active]
	guard
		se_idx = 10, bypassFlag = false
	do
		setRefTables(sps_id, sps_num_short_term_ref_pic_sets[sps_id], pcRPS, poc);
		idxNumPic := 0;
		se_idx    := 101;
	end
	
	read_SliceHeader.sendRefPOC.init_bypass : action ==> 
	guard
		se_idx = 10, bypassFlag = true
	do
		setRefTables(sps_id, sps_num_short_term_ref_pic_sets[sps_id], pcRPS, poc);
		idxNumPic := 0;
		se_idx    := 101;
	end
	
	
	read_SliceHeader.sendListEntryL0Flag : action ==> RefPicListModif:[ref_pic_list_modification_flag_lx[0]]
	guard
		se_idx = 101, bypassFlag = false
	do
		if ref_pic_list_modification_flag_lx[0] = 0 then
			se_idx := 201;
		else
			se_idx := 102;
		end
	end
	
	read_SliceHeader.sendListEntryL0Flag_bypass : action ==> 
	guard
		se_idx = 101, bypassFlag = true
	do
		if ref_pic_list_modification_flag_lx[0] = 0 then
			se_idx := 201;
		else
			se_idx := 102;
		end
	end

	read_SliceHeader.sendListEntryL0Loop : action ==> RefPicListModif:[list_entry_lx[0][cnt_i - 1]]
	guard
		se_idx = 102,
		cnt_i < num_ref_idx_l0_active, bypassFlag = false
	do
		cnt_i := cnt_i + 1;
	end
	
	read_SliceHeader.sendListEntryL0Loop_bypass : action ==> 
	guard
		se_idx = 102,
		cnt_i < num_ref_idx_l0_active, bypassFlag = true
	do
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.sendListEntryL0End : action ==>
	guard
		se_idx = 102,
		cnt_i = num_ref_idx_l0_active
	do
		cnt_i := 0;
		se_idx := 201;

	end

	read_SliceHeader.sendListEntryL1Flag : action ==> RefPicListModif:[ref_pic_list_modification_flag_lx[1]]
	guard
		se_idx = 201, bypassFlag = false
	do
		if ref_pic_list_modification_flag_lx[1] = 0 then
			se_idx := 11;
		else
			se_idx := 202;
		end
	end
	
	read_SliceHeader.sendListEntryL1Flag_bypass : action ==> 
	guard
		se_idx = 201, bypassFlag = true
	do
		if ref_pic_list_modification_flag_lx[1] = 0 then
			se_idx := 11;
		else
			se_idx := 202;
		end
	end

	read_SliceHeader.sendListEntryL1Loop : action ==> RefPicListModif:[list_entry_lx[1][cnt_i - 1]]
	guard
		se_idx = 202,
		cnt_i < num_ref_idx_l1_active, bypassFlag = false
	do
		cnt_i := cnt_i + 1;
	end
	
	read_SliceHeader.sendListEntryL1Loop_bypass : action ==> 
	guard
		se_idx = 202,
		cnt_i < num_ref_idx_l1_active, bypassFlag = true
	do
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.sendListEntryL1End : action ==>
	guard
		se_idx = 202,
		cnt_i = num_ref_idx_l1_active
	do
		cnt_i := 0;
		se_idx    := 11;
	end
        
	read_SliceHeader.sendRefPOC.sendSize : action ==> RefPoc:[refPocSize]
	guard
		se_idx = 11, bypassFlag = false
	var
				int(size=16) refPocSize = numPic[idxNumPic]
	do
		if numPic[idxNumPic] = 0 then
			idxNumPic := idxNumPic + 1;
			if idxNumPic = 5 then
				se_idx := 3;
			end
		else
			idxRefPoc := 0;
			se_idx    := 12;
		end
	end
	
	read_SliceHeader.sendRefPOC.sendSize_bypass : action ==> 
	guard
		se_idx = 11, bypassFlag = true
	do
		if numPic[idxNumPic] = 0 then
			idxNumPic := idxNumPic + 1;
			if idxNumPic = 5 then
				se_idx := 3;
			end
		else
			idxRefPoc := 0;
			se_idx    := 12;
		end
	end
	
	
	read_SliceHeader.sendRefPOC.sendRefPoc : action ==> RefPoc:[refPoc]
	guard
		se_idx = 12, bypassFlag = false
	var
		int(size=16) refPoc = pocTables[idxNumPic][idxRefPoc]
	do
		idxRefPoc := idxRefPoc + 1;
		if idxRefPoc = numPic[idxNumPic] then
			idxNumPic := idxNumPic + 1;
			if idxNumPic = 5 then
				se_idx := 3;
			else
				se_idx := 11;
			end
		end
	end
	
	read_SliceHeader.sendRefPOC.sendRefPoc_bypass : action ==> 
	guard
		se_idx = 12, bypassFlag = true
	do
		idxRefPoc := idxRefPoc + 1;
		if idxRefPoc = numPic[idxNumPic] then
			idxNumPic := idxNumPic + 1;
			if idxNumPic = 5 then
				se_idx := 3;
			else
				se_idx := 11;
			end
		end
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_3
	 *************************************************************************/
	 int(size= 8) slice_qp;
	 int(size= 8) slice_cb_qp_offset;
	 int(size= 8) slice_cr_qp_offset;
	uint(size=16) MaxNumMergeCand;
	uint(size= 1) cabac_init_flag;
		uint(size= 1) collocated_from_lX := 0;
		uint(size= 3) collocated_ref_idx := 0;

	read_SliceHeader.se_idx_3 : action ==> WeightedPredLuma:[weighted_pred_flag], WeightedPredChroma:[weighted_pred_flag]
	guard
		se_idx = 3 and isFifoFull(fifo), bypassFlag = false
	var
		uint(size=32) res[1],
		uint(size= 2) weighted_pred_flag := 0,
				uint(size= 1) collocated_from_l0_flag := 1
	do
				collocated_from_lX := 0;
				collocated_ref_idx := 0;
		cabac_init_flag := 0;
		se_idx := 5;

		if slice_type = P_SLICE or slice_type = B_SLICE then
			if pps_cabac_init_present_flag[pps_id] = 1	then
				vld_u_name(  1, fifo, res, "cabac_init_flag                         ");
				cabac_init_flag := res[0];
			end
			if slice_temporal_mvp_enable_flag = 1 then
				res[0] := 1;
				if( slice_type = B_SLICE ) then
					vld_u_name(  1, fifo, res, "collocated_from_l0_flag                 ");
					collocated_from_l0_flag := res[0];
					collocated_from_lX := res[0];
				end
				if ( collocated_from_l0_flag = 1 and num_ref_idx_l0_active > 1 ) or ( collocated_from_l0_flag = 0 and num_ref_idx_l1_active > 1 ) then
					vld_ue_name(    fifo, res, "collocated_ref_idx                      ");
					collocated_ref_idx := res[0];
				end
			end
			if pps_weighted_pred_flag[pps_id] = 1 or pps_weighted_bipred_flag[pps_id] = 1 then
				weighted_pred_flag := 1;
			end

			if weighted_pred_flag != 0 then
				se_idx := 4;
			end
		end
	end
	
	read_SliceHeader.se_idx_3_bypass : action ==> 
	guard
		se_idx = 3 and isFifoFull(fifo), bypassFlag = true
	var
		uint(size=32) res[1],
		uint(size= 2) weighted_pred_flag := 0,
				uint(size= 1) collocated_from_l0_flag := 1
	do
				collocated_from_lX := 0;
				collocated_ref_idx := 0;
		cabac_init_flag := 0;
		se_idx := 5;

		if slice_type = P_SLICE or slice_type = B_SLICE then
			if pps_cabac_init_present_flag[pps_id] = 1	then
				vld_u_name(  1, fifo, res, "cabac_init_flag                         ");
				cabac_init_flag := res[0];
			end
			if slice_temporal_mvp_enable_flag = 1 then
				res[0] := 1;
				if( slice_type = B_SLICE ) then
					vld_u_name(  1, fifo, res, "collocated_from_l0_flag                 ");
					collocated_from_l0_flag := res[0];
					collocated_from_lX := res[0];
				end
				if ( collocated_from_l0_flag = 1 and num_ref_idx_l0_active > 1 ) or ( collocated_from_l0_flag = 0 and num_ref_idx_l1_active > 1 ) then
					vld_ue_name(    fifo, res, "collocated_ref_idx                      ");
					collocated_ref_idx := res[0];
				end
			end
			if pps_weighted_pred_flag[pps_id] = 1 or pps_weighted_bipred_flag[pps_id] = 1 then
				weighted_pred_flag := 1;
			end

			if weighted_pred_flag != 0 then
				se_idx := 4;
			end
		end
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_4
	 *************************************************************************/
	uint(size= 1) luma_weight_l0_flag[16];
	uint(size= 1) chroma_weight_l0_flag[16];
	 int(size= 8) delta_luma_weight_l0;
	 int(size= 8) luma_offset_l0;
	 int(size= 8) delta_chroma_weight_l00;
	 int(size= 8) delta_chroma_weight_l01;
	 int(size= 10) delta_chroma_offset_l00;
	 int(size= 10) delta_chroma_offset_l01;

	uint(size= 1) luma_weight_l1_flag[16];
	uint(size= 1) chroma_weight_l1_flag[16];
	 int(size= 8) delta_luma_weight_l1;
	 int(size= 8) luma_offset_l1;
	 int(size= 8) delta_chroma_weight_l10;
	 int(size= 8) delta_chroma_weight_l11;
	 int(size= 10) delta_chroma_offset_l10;
	 int(size= 10) delta_chroma_offset_l11;

	weighted_start : action ==> WeightedPredLuma:[luma_log2_weight_denom, delta_chroma_log2_weight_denom],
											 WeightedPredChroma:[luma_log2_weight_denom, delta_chroma_log2_weight_denom]
	guard
		se_idx = 4 and isFifoFull(fifo),
		slice_type = P_SLICE or slice_type = B_SLICE,
		(pps_weighted_pred_flag[pps_id] = 1 and slice_type = P_SLICE) or ( pps_weighted_bipred_flag[pps_id] = 1 and slice_type = B_SLICE )
	var
		uint(size=32) res[1],
		uint(size= 3) luma_log2_weight_denom := 0,
		 int(size= 4) delta_chroma_log2_weight_denom :=0
	do
		vld_ue_name(    fifo, res, "luma_log2_weight_denom                  ");
		luma_log2_weight_denom := res[0];
		if sps_chroma_format_idc[sps_id] != 0 then
			vld_se_name(    fifo, res, "delta_chroma_log2_weight_denom          ");
			delta_chroma_log2_weight_denom := res[0];
		end
	end

	weighted_luma_l0 : action ==> WeightedPredLuma:[luma_weight_l0_flag[cnt_i - 1]]
	guard
                isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "luma_weight_lX_flag                     ");
		luma_weight_l0_flag[cnt_i] := res[0];
		cnt_i := cnt_i +1;
	end

        weighted_end_luma_l0 : action ==>
	guard
                isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active
	do
		cnt_i := 0;
	end

	weighted_chroma_l0 : action ==> WeightedPredChroma:[chroma_weight_l0_flag[cnt_i - 1]]
	guard
                isFifoFull(fifo),
                sps_chroma_format_idc[sps_id] = 1
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "chroma_weight_lX_flag                   ");
		chroma_weight_l0_flag[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end

        weighted_end_chroma_l0 : action ==>
	guard
                isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active
	do
		cnt_i := 0;
	end


        weighted_deltaLuma_l0_skip_loop : action ==>
	guard
                isFifoFull(fifo),
		luma_weight_l0_flag[cnt_i] = 0,
		chroma_weight_l0_flag[cnt_i] = 0,
		cnt_i < num_ref_idx_l0_active
	do
		cnt_i := cnt_i + 1;
	end

        weighted_deltaLuma_l0_skip_loop_done : action ==>
	guard
                isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active,
		slice_type = B_SLICE
	do
		cnt_i := 0;
	end

        weighted_deltaLuma_l0__skip_all : action ==>
	guard
                isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active,
		slice_type != B_SLICE
	do
		cnt_i := 0;
		se_idx := 5;
	end

	weighted_deltaLuma_l0_send : action ==> WeightedPredLuma:[delta_luma_weight_l0, luma_offset_l0]
	guard
                isFifoFull(fifo),
		luma_weight_l0_flag[cnt_i] = 1,
		cnt_i < num_ref_idx_l0_active
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_luma_weight_lX                    ");
		delta_luma_weight_l0 := res[0];
		vld_se_name(    fifo, res, "luma_offset_lX                          ");
		luma_offset_l0 := res[0];
	end

        weighted_deltaLuma_l0_skip : action ==>
	guard
                isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		luma_weight_l0_flag[cnt_i] = 0
	end

        weighted_deltaChroma_l0_skip : action ==>
	guard
                isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		chroma_weight_l0_flag[cnt_i] = 0
	do
		cnt_i := cnt_i + 1;
	end

	weighted_deltaChroma_l0_send : action ==> WeightedPredChroma:[delta_chroma_weight_l00]
	guard
                isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		chroma_weight_l0_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l00 := res[0];
	end

	weighted_deltaChroma_offset_l0_send : action ==> WeightedPredChroma:[delta_chroma_offset_l00, delta_chroma_weight_l01, delta_chroma_offset_l01]
	guard
                isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		chroma_weight_l0_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l00 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l01 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l01 := res[0];
		cnt_i := cnt_i + 1;
	end

	weighted_luma_l1 : action ==>  WeightedPredLuma:[luma_weight_l1_flag[cnt_i-1]]
	guard
                isFifoFull(fifo),
                slice_type = B_SLICE
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "luma_weight_lX_flag                     ");
		luma_weight_l1_flag[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end

        weighted_end_luma_l1 : action ==>
	guard
                isFifoFull(fifo),
		slice_type = B_SLICE,
		cnt_i = num_ref_idx_l1_active
	do
		cnt_i := 0;
	end

        weighted_chroma_l1_skip : action ==>
	guard
                isFifoFull(fifo),
		sps_chroma_format_idc[sps_id] = 0
	do
		cnt_i := 0;
	end

	weighted_chroma_l1 : action ==>  WeightedPredChroma:[chroma_weight_l1_flag[cnt_i - 1]]
	guard
                isFifoFull(fifo),
                sps_chroma_format_idc[sps_id] != 0
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "chroma_weight_lX_flag                   ");
		chroma_weight_l1_flag[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end

        weighted_end_chroma_l1 : action ==>
	guard
                isFifoFull(fifo),
		sps_chroma_format_idc[sps_id] != 0,
		cnt_i = num_ref_idx_l1_active
	do
		cnt_i := 0;
	end

        weighted_deltaLuma_l1_skip_loop : action ==>
	guard
                isFifoFull(fifo),
		luma_weight_l1_flag[cnt_i] = 0,
                chroma_weight_l1_flag[cnt_i] = 0
	do
		cnt_i := cnt_i + 1;
	end

        weighted_deltaLuma_l1_skip_loop_done : action ==>
	guard
                isFifoFull(fifo),
		cnt_i = num_ref_idx_l1_active
	do
		cnt_i := 0;
		se_idx := 5;
	end

	weighted_deltaLuma_l1_send : action ==> WeightedPredLuma:[delta_luma_weight_l1, luma_offset_l1]
	guard
                isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		luma_weight_l1_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_luma_weight_lX                    ");
		delta_luma_weight_l1 := res[0];
		vld_se_name(    fifo, res, "luma_offset_lX                          ");
		luma_offset_l1 := res[0];
	end

        weighted_deltaLuma_l1_skip : action ==>
	guard
                isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		luma_weight_l1_flag[cnt_i] = 0
	end

        weighted_deltaChroma_l1_skip : action ==>
	guard
                isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		chroma_weight_l1_flag[cnt_i] = 0
	do
		cnt_i := cnt_i + 1;
	end

	weighted_deltaChroma_l1_send : action ==> WeightedPredChroma:[delta_chroma_weight_l10]
	guard
                isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		chroma_weight_l1_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l10 := res[0];
	end

	weighted_deltaChroma_offset_l1_send : action ==> WeightedPredChroma:[delta_chroma_offset_l10,delta_chroma_weight_l11,delta_chroma_offset_l11]
	guard
                isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		chroma_weight_l1_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l10 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l11 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l11 := res[0];
		cnt_i := cnt_i + 1;
	end

		
		uint(size=16) qp_bd_offset_luma;
	/**************************************************************************
	 * read_SliceHeader.se_idx_5
	 *************************************************************************/
	read_SliceHeader.se_idx_5 : action ==> DBFDisable:[slice_disable_deblocking_filter_flag !=0],
		DbfSe:[betaOff, tcOff, pps_cb_qp_offset[pps_id] + slice_cb_qp_offset, pps_cr_qp_offset[pps_id] + slice_cr_qp_offset]
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) slice_disable_deblocking_filter_flag := pps_disable_deblocking_filter_flag[pps_id],
		int(size=8) betaOff := pps_beta_offset[pps_id],
		int(size=8) tcOff := pps_tc_offset[pps_id]
	do
		if slice_type = P_SLICE or slice_type = B_SLICE then
			vld_ue_name(    fifo, res, "five_minus_max_num_merge_cand           ");
			MaxNumMergeCand := 5 - res[0];
		end
		vld_se_name(    fifo, res, "slice_qp_delta                          ");
		slice_qp := pps_init_qp_minus26[pps_id] + 26 +res[0];
		slice_cb_qp_offset := 0;
		slice_cr_qp_offset := 0;
				qp_y := slice_qp;
				qp_bd_offset_luma           := 6 * sps_bit_depth_luma_minus8[sps_id];
				if pps_cu_qp_delta_enabled_flag[pps_id] = 0 then
					qp_y    := ((slice_qp + 52 + 2 * qp_bd_offset_luma) mod (52 + qp_bd_offset_luma)) - qp_bd_offset_luma;
				end
		if pps_slice_chroma_qp_offsets_present_flag[pps_id] = 1 then
			vld_se_name(    fifo, res, "slice_cb_qp_offset                      ");
			slice_cb_qp_offset := res[0];
			vld_se_name(    fifo, res, "slice_cr_qp_offset                      ");
			slice_cr_qp_offset := res[0];
		end
		if(pps_deblocking_filter_control_present_flag[pps_id] = 1) then
		   res[0] := 0;
			if(deblocking_filter_override_enabled_flag[pps_id] = 1) then
						vld_u_name(1, fifo, res,
						"deblocking_filter_override_flag         ");
			end
			if res[0] = 1 then
						vld_u_name(1, fifo, res,
						"slice_disable_deblocking_filter_flag    ");
				slice_disable_deblocking_filter_flag := res[0];
				if( slice_disable_deblocking_filter_flag = 0) then
							vld_se_name(fifo, res,
							"beta_offset_div2                        ");
					betaOff := res[0] << 1;
							vld_se_name(fifo, res,
							"tc_offset_div2                          ");
					tcOff := res[0] << 1;
				end
			end
		end
				if (pps_loop_filter_across_slice_enabled_flag[sps_id] = 1 and
				(slice_sample_adaptive_offset_flag[0] = 1 or
				slice_sample_adaptive_offset_flag[1] = 1 or
				slice_disable_deblocking_filter_flag = 0)) then
					vld_u_name(1, fifo, res,
					"slice_loop_filter_across_slices_enabled_flag");
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader_done
	 *************************************************************************/
//         procedure initWpScaling()
//         begin
//                foreach uint(size=8) e in 0 .. 1 do
//                        foreach uint(size=8) i in 0 .. MAX_NUM_REF-1 do
//                                foreach uint(size=8) yuv in 0 .. 2 do
//                                        if wp[e][i][yuv][WP_PRESENT_FLAG] = 1 then
//                                                wp[e][i][yuv][WP_I_WEIGHT] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]);
//                                                wp[e][i][yuv][WP_I_OFFSET] := 0;
//                                        end
//                                        wp[e][i][yuv][WP_W]     := wp[e][i][yuv][WP_I_WEIGHT];
//                                        wp[e][i][yuv][WP_O]     := wp[e][i][yuv][WP_I_OFFSET] * (1);
//                                        wp[e][i][yuv][WP_SHIFT] := wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM];
//                                        if wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM] >= 1 then
//                                                wp[e][i][yuv][WP_ROUND] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]) - 1;
//                                        else
//                                                wp[e][i][yuv][WP_ROUND] := 0;
//                                        end
//                                end
//                        end
//                end
//        end
	uint(size=16) num_entry_point_offsets := 0;
	uint(size=16) offset_len;
        uint(size=16) slice_segment_header_extension_length;
	uint num_entry_offsets := 0;

		read_SliceHeader.se_idx_6 : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		se_idx := 8;
            if pps_tiles_enabled_flag[pps_id] = 1 or pps_entropy_coding_sync_enabled_flag[pps_id] = 1 then
			vld_ue_name(fifo, res, "num_entry_point_offsets                 ");
			num_entry_point_offsets := res[0];
			if num_entry_point_offsets > NUM_ENTRY_MAX then
				println("ERROR: fix NUM_ENTRY_MAX");
			end
			if num_entry_point_offsets > 0 then
            		vld_ue_name(fifo, res,
            		"offset_len_minus1                       ");
				offset_len := res[0] + 1;
				se_idx := 7;
			end
		end
		if TILE_SPLIT_ENABLE != 0 then
			num_entry_offsets := 1;
		else
			num_entry_offsets := (pps_num_tile_columns_minus1[pps_id] + 1) *
			(pps_num_tile_rows_minus1[pps_id] + 1);
		end
	end

	read_SliceHeader.se_idx_7_loop : action ==>
	guard
		se_idx = 7 and isFifoFull(fifo), cnt_i < num_entry_point_offsets
	var
		uint(size=32) res[1]
	do
		if offset_len > 32 then
			println("ERROR with vld_ue : check offset_len size");
		end
		vld_u_name(  offset_len, fifo, res, "entry_point_offset                      ");
		entryOffsetsTab[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.se_idx_7_endLoop : action ==>
	guard
		se_idx = 7 and isFifoFull(fifo), cnt_i = num_entry_point_offsets
	do
		cnt_i := 0;
		se_idx := 8;
	end

	read_SliceHeader.se_idx_8 : action ==>
	guard
		se_idx = 8 and isFifoFull(fifo)
	var
	            int(size=32) res[1]
	do
		se_idx := 100;
		if pps_slice_segment_header_extension_present_flag[pps_id] = 1 then
			vld_ue_name(    fifo, res, "slice_segment_header_extension_length   ");
			slice_segment_header_extension_length := res[0];
			se_idx := 9;
		        cnt_i := 0;
		end
	end

	read_SliceHeader.se_idx_9_loop : action ==>
	guard
            se_idx = 9 and isFifoFull(fifo) and cnt_i < slice_segment_header_extension_length
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "slice_segment_header_extension_data_byte");
	        cnt_i := cnt_i + 1;
	end

	read_SliceHeader.se_idx_9_endLoop : action ==>
	guard
		se_idx = 9 and isFifoFull(fifo), cnt_i = slice_segment_header_extension_length
	do
		cnt_i := 0;
		se_idx := 100;
	end

	uint totalByPass := 0;

	read_SliceHeader_done : action ==> StrongIntraSmoothing:[sps_strong_intra_smoothing_enable_flag[sps_id], pps_constrained_intra_pred_flag[pps_id]]
	guard
		se_idx = 100, bypassFlag = false
	do
		if DEBUG_CABAC or CHECK_CABAC then
			println("\tPOC: "+poc);
		end
            first_qp_group := if dependent_slice_segment_flag = 1 then 0 else 1 end;
            if (pps_cu_qp_delta_enabled_flag[pps_id] = 0) then
        		qp_y := slice_qp;
        	end
		sliceData_idx := 1;
		totalByPass := 0;
		if num_entry_point_offsets > 0 and TILE_SPLIT_ENABLE != 0 then //bypass
			if TilesInfo[1] != 0 then
				byPassFlag := true;
				byte_align(fifo);
				foreach int k in 0 .. TilesInfo[1] - 1 do
					totalByPass := totalByPass + entryOffsetsTab[k];
				end
			end
		end
	end
	
	read_SliceHeader_done_bypass : action ==> 
	guard
		se_idx = 100, bypassFlag = true
	do
		if DEBUG_CABAC or CHECK_CABAC then
			println("\tPOC: "+poc);
		end
            first_qp_group := if dependent_slice_segment_flag = 1 then 0 else 1 end;
            if (pps_cu_qp_delta_enabled_flag[pps_id] = 0) then
        		qp_y := slice_qp;
        	end
		sliceData_idx := 1;
		totalByPass := 0;
		if num_entry_point_offsets > 0 and TILE_SPLIT_ENABLE != 0 then //bypass
			if TilesInfo[1] != 0 then
				byPassFlag := true;
				byte_align(fifo);
				foreach int k in 0 .. TilesInfo[1] - 1 do
					totalByPass := totalByPass + entryOffsetsTab[k];
				end
			end
		end
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Slice Data                           *********************
	 **************************************************************************
	 *************************************************************************/
	int countAEB := 0;
	uint(size= 9) codIRange[1];
	uint(size=16) codIOffset[1];
	uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX];
	uint(size= 9) ctxTableWPP[NB_MAX_SE][NB_MAX_NUM_CTX];
	uint(size= 8) sliceData_idx;

	/**************************************************************************
	 * read_SliceData.init
	 *************************************************************************/
	//bool          isNotFirstSlice := (first_slice_segment_in_pic_flag = 0);
	uint(size= 8) prev_pps_id;

	uint(size= 8) Log2MinTrafoSize;
	uint(size= 8) Log2MaxTrafoSize;
	uint(size=16) ctbAddrRStoTS[CTB_ADDR_TS_MAX];
	uint(size=16) ctbAddrTStoRS[CTB_ADDR_TS_MAX];
	uint(size=16) TileId[CTB_ADDR_TS_MAX];
	uint(size=16) nbCtbTile[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
	uint(size=16) colTileInPix[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
	uint(size=16) rowTileInPix[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
	uint tile_idx := 0;
	uint(size= 1) skip_flag_tab[PICT_WIDTH][2];
	uint(size= 8) intraPredMode[PICT_WIDTH][2];
        uint(size=16) colWidth[NB_MAX_PPS][PICT_WIDTH / MIN_CTB_SIZE_Y];
        uint(size=16) rowHeight[NB_MAX_PPS][PICT_HEIGHT / MIN_CTB_SIZE_Y];

		read_SliceData.init: action ==> IsPicSlcLcu:[0], MvPredSyntaxElem:[pps_log2_parallel_merge_level[pps_id], slice_temporal_mvp_enable_flag ,collocated_from_lX , collocated_ref_idx],
										SaoSeLuma:[slice_sample_adaptive_offset_flag[0] + (slice_sample_adaptive_offset_flag[1]<<1)],
										SaoSeChromaU:[slice_sample_adaptive_offset_flag[0] + (slice_sample_adaptive_offset_flag[1]<<1)],
										SaoSeChromaV:[slice_sample_adaptive_offset_flag[0] + (slice_sample_adaptive_offset_flag[1]<<1)],
										LFAcrossSlcTile:[pps_loop_filter_across_slice_enabled_flag[pps_id] + (pps_loop_filter_across_slice_enabled_flag[pps_id]<<1)],
										PictSize:[pictSize] repeat 2 , TileSize:[pictOrTileSize] repeat 2, PicSizeInMb:[pictSize] repeat 2,
										DispCoord:[0, pictSize[0]-1, 0, pictSize[1]-1], TilesCoord:[num_entry_offsets], RealTilesCoord:[num_entry_offsets],
										ReorderPics:[no_output_of_prior_pics_flag, sps_num_reorder_pics[sps_id], pic_output_flag, video_sequence_id]
	guard
		sliceData_idx = 1 and isFifoFull(fifo),
		first_slice_segment_in_pic_flag = 1 or prev_pps_id != pps_id
	var
		uint(size= 8) num_tile_columns_minus1		= pps_num_tile_columns_minus1[pps_id],
		uint(size= 8) num_tile_rows_minus1			= pps_num_tile_rows_minus1[pps_id],
		uint(size=16) ColBd[PICT_WIDTH / MIN_CTB_SIZE_Y],
		uint(size=16) RowBd[PICT_HEIGHT / MIN_CTB_SIZE_Y],
		uint(size=16) tileX,
		uint(size=16) tileY,
		uint(size=16) val,
		uint(size=16) tbX,
		uint(size=16) tbY,
		uint(size=16) tIdx,
		uint count :=0
	do
		//isNotFirstSlice   := true;
		prev_pps_id       := pps_id;
        skip_flag_tab := [ [ 0 : for int j in 0 .. 1 ] : for int i in
        0 .. PICT_WIDTH - 1 ];
//                qp_y_tab := [ 0 : for int i in  0 .. (4096 * 2048) - 1 ];
        intraPredMode := [ [ INTRA_DC : for int j in 0 .. 1 ] : for
        int i in 0 .. PICT_WIDTH - 1 ];
//                first_qp_group := 1;
		Log2MinTrafoSize  := sps_log2_min_transform_block_size[sps_id] ;
		Log2MaxTrafoSize := Log2MinTrafoSize +
		sps_log2_diff_max_min_transform_block_size[sps_id];
		foreach int i in 0 .. num_tile_rows_minus1 do
			foreach int j in 0 .. num_tile_columns_minus1 do
				if count = 0 then
                			nbCtbTile[count] := rowHeight[pps_id][i] * colWidth[pps_id][j];
				else
                			nbCtbTile[count] := nbCtbTile[count - 1] + rowHeight[pps_id][i] * colWidth[pps_id][j];
				end //println("nbCtbTile[count]"+nbCtbTile[count]);
				count := count + 1;
			end
		end
		ColBd[ 0 ] := 0;
		foreach int i in 0 .. num_tile_columns_minus1 do
                	ColBd[i + 1] := ColBd[i] + colWidth[pps_id][i];
		end
		RowBd[ 0 ] := 0;
		foreach int i in 0 .. num_tile_rows_minus1 do
                	RowBd[i + 1] := RowBd[i] + rowHeight[pps_id][i];
		end

		/*********************************************************************
		 * 6.5 Conversion process for coding tree block address
		 * in coding tree block raster order to tile scan order
		 ********************************************************************/
		if PicHeightInCtbsY * PicWidthInCtbsY >= CTB_ADDR_TS_MAX then
			println("Error read_SliceData.init : CtbAddrTS : "+(PicHeightInCtbsY * PicWidthInCtbsY)+" >= "+CTB_ADDR_TS_MAX);
		end
		foreach int ctbAddrRS_v in 0 .. PicSizeInCtbsY - 1 do
			tbX   := ctbAddrRS_v mod PicWidthInCtbsY;
			tbY   := ctbAddrRS_v / PicWidthInCtbsY;
			tileX := 0;
			tileY := 0;
			foreach int i in 0 .. num_tile_columns_minus1 do
				if tbX < ColBd[i + 1] then
					tileX := i;
					i := num_tile_columns_minus1;
				end
			end
			foreach int j in 0 .. num_tile_rows_minus1 do
				if tbY < RowBd[j + 1] then
					tileY := j;
					j := num_tile_rows_minus1;
				end
			end
			val := 0;
			foreach int i in 0 .. tileX-1 do
                                val := val + rowHeight[pps_id][ tileY ] * colWidth[pps_id][ i ];
			end
			foreach int j in 0 .. tileY-1 do
                                val := val + PicWidthInCtbsY * rowHeight[pps_id][ j ];
			end
                        val                                              := val + ( tbY - RowBd[tileY] ) * colWidth[pps_id][tileX] + tbX - ColBd[tileX];
			ctbAddrRStoTS[ ctbAddrRS_v ] := val;
			ctbAddrTStoRS[ val ] 		 := ctbAddrRS_v;
		end

		tIdx := 0;
		foreach int j in 0 .. num_tile_rows_minus1 do
			foreach int i in 0 .. num_tile_columns_minus1 do
				foreach int y in RowBd[ j ] .. RowBd[ j + 1 ] - 1 do
					foreach int x in ColBd[ i ] .. ColBd[ i + 1 ] - 1 do
						TileId[ ctbAddrRStoTS[ y*PicWidthInCtbsY + x ] ] := tIdx;
					end
				end
				tIdx := tIdx + 1;
			end
		end
		InitScanningArray(ScanOrder);
		if num_entry_offsets > 0 then
			sliceData_idx := 20;
		else
			sliceData_idx := 21;
		end
	end

	read_SliceData.sendInfoSlice: action ==> TilesCoord:[0 ,0 ,pictSize[0] ,pictSize[1]]
	guard
		sliceData_idx = 21
	do
		sliceData_idx := 2;
	end

	uint countRow := 0;
	uint countCol := 0;

	read_SliceData.sendInfoTilesLoop: action ==> TilesCoord:[x0 ,y0 ,x1 ,y1]
	guard
				sliceData_idx = 20,  cnt_i < num_entry_offsets
	var
		uint x0 := 0,
		uint y0 := 0,
		uint x1 := pictSize[0],
		uint y1 := pictSize[1]
	do
		//colTileInPix[0] :=0;
		x0 := colTileInPix[countCol];
		x1 := colTileInPix[countCol + 1];
		y0 := rowTileInPix[countRow];
		y1 := rowTileInPix[countRow + 1];

		countCol := countCol + 1;
		if countCol  = pps_num_tile_columns_minus1[pps_id]+1 then
			countCol := 0;
			countRow := countRow + 1;
		end
		cnt_i := cnt_i + 1;
		if TILE_SPLIT_ENABLE = 1 then
			x0 := 0;
			x1 := pictOrTileSize[0];
			y0 := 0;
			y1 := pictOrTileSize[1];
		end
	end

	read_SliceData.sendRealInfoTilesLoop: action ==> RealTilesCoord:[x0 ,y0 ,x1 ,y1]
	guard
				sliceData_idx = 22,  cnt_i < num_entry_offsets
	var
		uint x0 := 0,
		uint y0 := 0,
		uint x1 := pictSize[0],
		uint y1 := pictSize[1]
	do
		x0 := colTileInPix[countCol];
		x1 := colTileInPix[countCol + 1];
		y0 := rowTileInPix[countRow];
		y1 := rowTileInPix[countRow + 1];

		countCol := countCol + 1;
		if countCol  = pps_num_tile_columns_minus1[pps_id]+1 then
			countCol := 0;
			countRow := countRow + 1;
		end
		cnt_i := cnt_i + 1;
	end

	read_SliceData.senInfoTilesEnd: action ==>
	guard
				sliceData_idx = 20,  cnt_i = num_entry_offsets
	do
		countCol := 0;
		countRow := 0;
		cnt_i    := 0;
		sliceData_idx := 22;
	end

	read_SliceData.senRealInfoTilesEnd: action ==>
	guard
				sliceData_idx = 22,  cnt_i = num_entry_offsets
	do
		countCol := 0;
		countRow := 0;
		cnt_i    := 0;
		sliceData_idx := 2;
	end

	read_SliceData.noInit: action ==> MvPredSyntaxElem:[pps_log2_parallel_merge_level[pps_id], slice_temporal_mvp_enable_flag]
	guard
		sliceData_idx = 1,
		first_slice_segment_in_pic_flag = 0 and dependent_slice_segment_flag = 1 and prev_pps_id = pps_id
	do
		sliceData_idx := 2;
	end

	read_SliceData.noInit_isSlc: action ==> MvPredSyntaxElem:[pps_log2_parallel_merge_level[pps_id],slice_temporal_mvp_enable_flag, collocated_from_lX , collocated_ref_idx],
        										IsPicSlcLcu:[1], TilesCoord:[num_entry_offsets], RealTilesCoord:[num_entry_offsets],
        										LFAcrossSlcTile:[pps_loop_filter_across_slice_enabled_flag[pps_id] + (pps_loop_filter_across_slice_enabled_flag[pps_id]<<1)],
        										PictSize:[pictSize] repeat 2, TileSize:[pictOrTileSize] repeat 2
		guard
			sliceData_idx = 1,
			first_slice_segment_in_pic_flag = 0 and dependent_slice_segment_flag = 0 and prev_pps_id = pps_id
		do

		if num_entry_offsets > 0 then
			sliceData_idx := 20;
		else
			sliceData_idx := 21;
		end
	end
	/**************************************************************************
	 * read_SliceData.start
	 *************************************************************************/
	//bool flag := true;
	uint(size=32) CtbAddrRS;
	uint(size=32) CtbAddrTS;
	uint(size=32) end_of_slice_flag;

	read_SliceData.start : action ==> SliceAddr:[xCtb, yCtb]
	guard
                sliceData_idx = 2
	var
		uint(size=32) CtbSize = 1 << Log2CtbSize
	do
                //showBits(8, fifo, res);
		//println("showbits8Start = " + res[0]);
				//println("initTab");
		CtbAddrRS     := slice_segment_address;
		CtbAddrTS     := ctbAddrRStoTS[CtbAddrRS];
		xCtb           := InverseRasterScan( CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 0 ) ;
		yCtb           := InverseRasterScan( CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 1 ) ;
		end_of_slice_flag  := 0;
		sliceData_idx := 3;
	end
	/**************************************************************************
	 * read_SliceData_gotoCodingTree
	 *************************************************************************/
	read_SliceData_gotoCodingTree.start : action ==>
	guard
		sliceData_idx = 3, byPassFlag = false
	do
		sliceData_idx  := 4;
		codingTree_idx := 1;
	end

	read_SliceData_gotoCodingTree.byPass : action ==>
	guard
		sliceData_idx = 3, byPassFlag = true
	do
		sliceData_idx  := 4;
		codingTree_idx := 0;
	end

	read_CodingTree.byPassBeforeTileLoop: action ==>
	guard
		codingTree_idx = 0 and isFifoFull(fifo), cnt_i < totalByPass + TilesInfo[1]
	do
		if (localizeAEB & 1) = 0 then
			flushBits_name(8, fifo, "bypassed");
		else
			countAEB := countAEB + 1;
		end
		//println("bypassed " + cnt_i);
		cnt_i := cnt_i + 1;
	end

	read_CodingTree.byPassBeforeTileEnd: action ==>
	guard
		codingTree_idx = 0 and isFifoFull(fifo), cnt_i = totalByPass + TilesInfo[1]
	do
		//println("totalByPass = " +totalByPass);
		cnt_i := 0;
		byPassFlag := false;
		codingTree_idx := 1;
		//flushBits_name(8, fifo, "bypassed");
		tile_idx := TilesInfo [1];
		CtbAddrTS := nbCtbTile[tile_idx - 1];
		//println("CtbAddrTS" + CtbAddrTS);
		CtbAddrRS := ctbAddrTStoRS[CtbAddrTS];
		//println("CtbAddrRS" + CtbAddrRS);
	end

		int counter := 0;

	read_SliceData.retCodingTree : action ==>
	guard
		sliceData_idx = 4 and isFifoFull(fifo)
	var
		uint(size=32) res[1] := [0]
	do
		//println("retcodingtree");
		get_END_OF_SLICE_FLAG(codIRange, codIOffset, fifo, res);
		end_of_slice_flag := res[0];
		CtbAddrTS := CtbAddrTS + 1;
		CtbAddrRS := ctbAddrTStoRS[CtbAddrTS];
                if pps_entropy_coding_sync_enabled_flag[pps_id] != 0 and 
                (CtbAddrTS mod PicWidthInCtbsY = 2 or (sps_ctb_width[sps_id] = 2 and CtbAddrTS mod sps_ctb_width[sps_id] = 0 )) then
                	//println("saveStates ctbaddrts = " + CtbAddrTS);
				ctxTableWPP := [[ctxTable[i][j]	    : for int j in 0 .. NB_MAX_NUM_CTX-1] : for int i in 0 .. NB_MAX_SE-1];
			end
                if end_of_slice_flag = 0 then
                    
			sliceData_idx := 3;
                    if pps_tiles_enabled_flag[pps_id] != 0 and (TileId[ CtbAddrTS ] != TileId[ CtbAddrTS - 1]) then
				//println("endOfTile ###################################################");
				if TILE_SPLIT_ENABLE = 0 then
					sliceData_idx := 3;
				else
					sliceData_idx := 5;
				end
			end
		else
			//println("endOfSlice ################################################### counter = " + counter);
						counter := counter + 1;
			sliceData_idx := 5;
			//curr_Tile := 0;
			CtbAddrTS := 0;
			CtbAddrRS := 0;
			//numByPassBytes := [0: for int i in 0 .. MAX_NUM_TILES - 1];
			byPassFlag := false;
		end
	end
	/**************************************************************************
	 * read_SliceData_end
	 *************************************************************************/
	read_SliceData_end: action ==>
	guard
		sliceData_idx = 5
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Coding Tree                          *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size=16) xCtb;
	uint(size=16) yCtb;
	uint(size= 8) codingTree_idx;
	uint(size= 8) ctStack_idx;
	uint(size=16) ctStack[5][CT_STRUCT_SIZE];
		uint(size=8) first_qp_group;
		bool ctb_left_flag;
		bool ctb_up_flag;
		int ctb_addr_in_slice ;
//	    int tab_slice_address[4096] := [-1 : for int i in 0 .. 4095]; // size to be checked (TODO)
//	    uint(size=8) slice_or_tiles_left_boundary;
//	    uint(size=8) slice_or_tiles_up_boundary;
//	    bool ctb_up_right_flag;
//	    bool ctb_up_left_flag;
	    
	/**************************************************************************
	 * read_CodingTree.start
	 *************************************************************************/
	read_CodingTree.start : action ==>
		guard
                codingTree_idx = 1 and isFifoFull(fifo)
		var
				uint(size=32) res[1],
				uint(size=32) CtbSize = 1 << Log2CtbSize,
				uint CtbAddrRS := ctbAddrTStoRS[CtbAddrTS],
				int tile_left_boundary,
				int tile_up_boundary,
//                int slice_left_boundary,
//                int slice_up_boundary,
				uint indexTS := 0,
				uint indexRS_0 := 0,
				uint indexRS_1 := 0
		do
			ctb_addr_in_slice := CtbAddrRS - slice_addr; //println("initcabac");
			if CtbAddrTS != 0 then
				indexTS := CtbAddrTS - 1;
			end
			if CtbAddrRS != 0 then
				indexRS_0 := CtbAddrRS - 1;
			end
			if CtbAddrRS >= sps_ctb_width[sps_id] then
				indexRS_1 := CtbAddrRS - sps_ctb_width[sps_id];
			end
//			tab_slice_address[CtbAddrRS] := slice_addr;
			xCtb := InverseRasterScan(CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 0);
			yCtb := InverseRasterScan(CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 1);
            if pps_entropy_coding_sync_enabled_flag[pps_id] != 0 then
				if (xCtb = 0 and (yCtb & (CtbSize - 1)) = 0) then
					first_qp_group := 1;
				end
            elsif pps_tiles_enabled_flag[pps_id] != 0 then 
        		if (CtbAddrTS != 0 and TileId[CtbAddrTS] != TileId[indexTS]) then
					first_qp_group := 1;
				end
			end
			if (pps_tiles_enabled_flag[pps_id] = 1) then
				tile_left_boundary := if (xCtb > 0 && TileId[CtbAddrTS] != TileId[ctbAddrRStoTS[indexRS_0]]) then
					1
				else
					0
				end;

				tile_up_boundary := if (yCtb > 0 && TileId[CtbAddrTS] != TileId[ctbAddrRStoTS[indexRS_1]]) then
					1
				else
					0
				end;
//            	slice_left_boundary := if (xCtb > 0 && tab_slice_address[CtbAddrRS] != tab_slice_address[indexRS_0]) then
//            		1 
//            	else 
//            		0 
//            	end;
//        		slice_up_boundary   := if (yCtb > 0 && tab_slice_address[CtbAddrRS] != tab_slice_address[indexRS_1])then
//        			1
//        		else
//        			0
//        		end;
			else
				tile_left_boundary := 0;
				tile_up_boundary := 0;
//            	slice_left_boundary := if (ctb_addr_in_slice <= 0) then 1 else 0 end;
//        		slice_up_boundary   := if (ctb_addr_in_slice < sps_ctb_width[sps_id]) then 1 else 0 end;
			end
            //slice_or_tiles_left_boundary := slice_left_boundary + (tile_left_boundary << 1);
    		//slice_or_tiles_up_boundary   := slice_up_boundary   + (tile_up_boundary   << 1);
			ctb_left_flag := (xCtb > 0) and (ctb_addr_in_slice > 0) and (tile_left_boundary = 0);

			ctb_up_flag := (yCtb > 0) && (ctb_addr_in_slice >= sps_ctb_width[sps_id]) && tile_up_boundary = 0;
//           ctb_up_right_flag := ((yCtb > 0)                && (ctb_addr_in_slice+1 >= sps_ctb_width[sps_id]) && (TileId[CtbAddrTS] = TileId[ctbAddrRStoTS[CtbAddrRS+1 - sps_ctb_width[sps_id]]]));
//    		ctb_up_left_flag  := ((xCtb > 0) && (yCtb > 0)  && (ctb_addr_in_slice-1 >= sps_ctb_width[sps_id]) && (TileId[CtbAddrTS] = TileId[ctbAddrRStoTS[CtbAddrRS-1 - sps_ctb_width[sps_id]]]));

			codingTree_idx := 2;
            if CtbAddrTS = ctbAddrRStoTS[slice_segment_address] then 
//                println("codIRangeINITCABACbegin := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
            	decodeStart(codIRange, codIOffset, fifo); 
//            	println("codIRangeINITCABAC1 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
				if (dependent_slice_segment_flag = 0 or
            	(pps_tiles_enabled_flag[pps_id] != 0 and (TileId[CtbAddrTS] != TileId[indexTS]))) then
            		contextInit(slice_qp, slice_type, ctxTable, cabac_init_flag); 
//            		println("codIRangeINITCABAC2 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
			end
				if first_slice_segment_in_pic_flag = 0 and
            	pps_entropy_coding_sync_enabled_flag[pps_id] != 0 then
				if (CtbAddrTS mod PicWidthInCtbsY) = 0 then
					if PicWidthInCtbsY = 1 then
            				contextInit(slice_qp, slice_type, ctxTable, cabac_init_flag); 
//            				println("codIRangeINITCABAC3 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
						else
            				if dependent_slice_segment_flag != 0 then
            					ctxTable := [ [ ctxTableWPP[i][j] : for int j in 0 .. NB_MAX_NUM_CTX - 1 ] : for int i in 0 .. NB_MAX_SE - 1 ];
						 end
					end
				end
			end
		else
            	if CtbAddrTS = 0 or pps_tiles_enabled_flag[pps_id] != 0 and
            	(TileId[CtbAddrTS] != TileId[indexTS]) then 
            		decodeReInit(codIRange, codIOffset, fifo); 
//            		println("codIRangeINITCABAC4 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
            		contextInit(slice_qp, slice_type, ctxTable, cabac_init_flag); 
//            		println("codIRangeINITCABAC5 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
			end
            	if pps_entropy_coding_sync_enabled_flag[pps_id] != 0 then
				if (CtbAddrTS mod PicWidthInCtbsY) = 0 then
					get_END_OF_SUB_STREAM_ONE_BIT(codIRange, codIOffset, fifo, res);
            			decodeReInit(codIRange, codIOffset, fifo); 
//            			println("codIRangeINITCABAC6 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
					if PicWidthInCtbsY = 1 then
            				contextInit(slice_qp, slice_type, ctxTable, cabac_init_flag); 
//            				println("codIRangeINITCABAC7 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
					else
            				ctxTable := [ [ ctxTableWPP[i][j] : for int j in 0 .. NB_MAX_NUM_CTX - 1 ] : for int i in 0 .. NB_MAX_SE - 1 ];
					end
				end
			end
		end
//		println("codIRangeINITCABACfinal := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
	end
	/**************************************************************************
	 * read_CodingTree_gotoSaoParam
	 *************************************************************************/
	read_CodingTree_gotoSaoParam : action ==>
	guard
		codingTree_idx = 2,
		slice_sample_adaptive_offset_flag[0] = 1 or slice_sample_adaptive_offset_flag[1] = 1
	do
		codingTree_idx	:= 3;
		sao_idx			:= 1;
		sao_rx			:= xCtb >> Log2CtbSize;
		sao_ry			:= yCtb >> Log2CtbSize;
		sao_cIdx		:= 0;
	end
	read_CodingTree.noGotoSaoParam : action ==>
	guard
		codingTree_idx = 2,
		slice_sample_adaptive_offset_flag[0] = 0 and slice_sample_adaptive_offset_flag[1] = 0
	do
		codingTree_idx := 3;
	end
	/**************************************************************************
	 * read_CodingTree_gotoCodingQuadTree
	 *************************************************************************/
	read_CodingTree_gotoCodingQuadTree : action ==>  IsPicSlcLcu:[NEW_LCU]
	guard
		codingTree_idx = 3
	do
		codingTree_idx				:= 4;
		ctStack_idx					:= 0;
		ctStack[0][CT_idx]			:= 1;
		ctStack[0][CT_x0]			:= xCtb;
		ctStack[0][CT_y0]			:= yCtb;
		ctStack[0][CT_log2CbSize]	:= Log2CtbSize;
		ctStack[0][CT_ctDepth]		:= 0;
	end
	/**************************************************************************
	 * read_CodingTree_end
	 *************************************************************************/
	read_CodingTree_end : action ==>
	guard
		codingTree_idx = 4
	end
	/**************************************************************************
	 **************************************************************************
	 ********        sao_param                            *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 3) sao_cIdx;
	uint(size=16) sao_rx;
	uint(size=16) sao_ry;
	uint(size= 8) sao_idx;
	/**************************************************************************
	 * read_SaoParam.start
	 *************************************************************************/
	read_SaoParam.start : action ==> SaoSeChromaU:[sao_merge], SaoSeLuma:[sao_merge], SaoSeChromaV:[sao_merge]
	guard
		sao_idx = 1 and isFifoFull(fifo)
	var
		 int(size=32) res[1],
		uint(size= 1) sao_merge_left_flag	:= 0,
		uint(size= 1) sao_merge_up_flag		:= 0,
                 int(size= 9) sao_merge             := SAO_NO_MERGE
	do
		if sao_rx > 0 then
						if ctb_left_flag then
				get_SAO_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
				sao_merge_left_flag := res[0];
				if sao_merge_left_flag = 1 then
					sao_merge       := SAO_MERGE_LEFT;
				end
			end
		end
		if sao_ry > 0 and sao_merge_left_flag = 0 then
						if ctb_up_flag then
				get_SAO_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
				sao_merge_up_flag := res[0];
				if sao_merge_up_flag = 1 then
					sao_merge     := SAO_MERGE_UP;
				end
			end
		end
		sao_idx  := 2;
		if sao_merge_left_flag = 0 and sao_merge_up_flag = 0 then
			sao_cIdx := 0;
		else
			sao_cIdx := 3;
		end
	end
	/**************************************************************************
	 * read_SaoParam.loop
	 *************************************************************************/
	 int(size= 9) sao_typeIdx;
	 int(size= 9) sao_eo;
	read_SaoParam.loop.luma : action ==> SaoSeLuma:[sao_typeIdx]
	guard
		sao_idx  = 2 and isFifoFull(fifo),
		sao_cIdx = 0 and sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 1
	var
		 int(size=32) res[1]
	do
		if sao_cIdx != 2 then
			sao_typeIdx := SAO_NOT_APPLIED;
			get_SAO_TYPE_IDX(codIRange, codIOffset, ctxTable, fifo, res);
			sao_typeIdx := res[0];
		end
		if sao_typeIdx != SAO_NOT_APPLIED then
			sao_idx := 3;
		else
			sao_cIdx := sao_cIdx + 1;
		end
	end

	read_SaoParam.loop.chromaU : action ==> SaoSeChromaU:[sao_typeIdx]
	guard
		sao_idx  = 2 and isFifoFull(fifo),
		sao_cIdx = 1 and sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 1
	var
		 int(size=32) res[1]
	do
		if sao_cIdx != 2 then
			sao_typeIdx := SAO_NOT_APPLIED;
			get_SAO_TYPE_IDX(codIRange, codIOffset, ctxTable, fifo, res);
			sao_typeIdx := res[0];
		end
		if sao_typeIdx != SAO_NOT_APPLIED then
			sao_idx := 4;
		else
			sao_cIdx := sao_cIdx + 1;
		end
	end

	read_SaoParam.loop.chromaV : action ==> SaoSeChromaV:[sao_typeIdx]
	guard
		sao_idx  = 2 and isFifoFull(fifo),
		sao_cIdx = 2 and sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 1
	var
		 int(size=32) res[1]
	do
		if sao_cIdx != 2 then
			sao_typeIdx := SAO_NOT_APPLIED;
			get_SAO_TYPE_IDX(codIRange, codIOffset, ctxTable, fifo, res);
			sao_typeIdx := res[0];
		end
		if sao_typeIdx != SAO_NOT_APPLIED then
			sao_idx := 5;
		else
			sao_cIdx := sao_cIdx + 1;
		end
	end

	read_SaoParam.loop2_luma : action ==> SaoSeLuma:[offset[0],offset[1],offset[2],offset[3],sao_eo]
	guard
		sao_idx  = 3 and isFifoFull(fifo)
	var
		uint(size= 8) offsetTh   = (1<<3)-1,
		 int(size= 9) offset[4] := [0, 0, 0, 0],
		 int(size=32) res[1]    := [0]
	do
		foreach int i in 0 .. 3 do
			get_SAO_OFFSET_ABS(offsetTh, codIRange, codIOffset, fifo, res);
			offset[i] := res[0];
		end
		if sao_typeIdx = SAO_BAND then
			foreach int i in 0 .. 3 do
				if offset[i] != 0 then
					get_SAO_OFFSET_SIGN(codIRange, codIOffset, fifo, res);
					if res[0] != 0 then
						offset[i] := -offset[i];
					end
				end
			end
			get_SAO_BAND_POSITION(codIRange, codIOffset, fifo, res);
			sao_eo := res[0];
		else
			offset[2] := -offset[2];
			offset[3] := -offset[3];
			if sao_cIdx != 2 then
				get_SAO_EO(codIRange, codIOffset, fifo, res);
				sao_eo := res[0];
			end
		end
		sao_cIdx := sao_cIdx + 1;
		sao_idx  := 2;
	end

	read_SaoParam.loop2_chromaU : action ==> SaoSeChromaU:[offset[0],offset[1],offset[2],offset[3],sao_eo]
	guard
		sao_idx  = 4 and isFifoFull(fifo)
	var
		uint(size= 8) offsetTh   = (1<<3)-1,
		 int(size= 9) offset[4] := [0, 0, 0, 0],
		 int(size=32) res[1]    := [0]
	do
		foreach int i in 0 .. 3 do
			get_SAO_OFFSET_ABS(offsetTh, codIRange, codIOffset, fifo, res);
			offset[i] := res[0];
		end
		if sao_typeIdx = SAO_BAND then
			foreach int i in 0 .. 3 do
				if offset[i] != 0 then
					get_SAO_OFFSET_SIGN(codIRange, codIOffset, fifo, res);
					if res[0] != 0 then
						offset[i] := -offset[i];
					end
				end
			end
			get_SAO_BAND_POSITION(codIRange, codIOffset, fifo, res);
			sao_eo := res[0];
		else
			offset[2] := -offset[2];
			offset[3] := -offset[3];
			if sao_cIdx != 2 then
				get_SAO_EO(codIRange, codIOffset, fifo, res);
				sao_eo := res[0];
			end
		end
		sao_cIdx := sao_cIdx + 1;
		sao_idx  := 2;
	end

	read_SaoParam.loop2_chromaV : action ==> SaoSeChromaV:[offset[0],offset[1],offset[2],offset[3],sao_eo]
	guard
		sao_idx  = 5 and isFifoFull(fifo)
	var
		uint(size= 8) offsetTh   = (1<<3)-1,
		 int(size= 9) offset[4] := [0, 0, 0, 0],
		 int(size=32) res[1]    := [0]
	do
		foreach int i in 0 .. 3 do
			get_SAO_OFFSET_ABS(offsetTh, codIRange, codIOffset, fifo, res);
			offset[i] := res[0];
		end
		if sao_typeIdx = SAO_BAND then
			foreach int i in 0 .. 3 do
				if offset[i] != 0 then
					get_SAO_OFFSET_SIGN(codIRange, codIOffset, fifo, res);
					if res[0] != 0 then
						offset[i] := -offset[i];
					end
				end
			end
			get_SAO_BAND_POSITION(codIRange, codIOffset, fifo, res);
			sao_eo := res[0];
		else
			offset[2] := -offset[2];
			offset[3] := -offset[3];
			if sao_cIdx != 2 then
				get_SAO_EO(codIRange, codIOffset, fifo, res);
				sao_eo := res[0];
			end
		end
		sao_cIdx := sao_cIdx + 1;
		sao_idx  := 2;
	end

	read_SaoParam.nextLoop : action ==>
	guard
		sao_idx  = 2 ,
		sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 0
	do
		sao_cIdx := sao_cIdx + 1;
	end
	read_SaoParam_endLoop : action ==>
	guard
		sao_idx  = 2 ,
		sao_cIdx = 3
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Coding quadTree                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 1) IsCuQpDeltaCoded;
	 int(size=16) CuQpDelta;
		 uint(size= 8) ct_log2CbSize;
	/**************************************************************************
	 * read_CodingQuadTree.start
	 *************************************************************************/
	read_CodingQuadTree.start : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size=16) ct_x0			= ctStack[ctStack_idx][CT_x0],
		uint(size=16) ct_y0			= ctStack[ctStack_idx][CT_y0],
		uint(size= 8) ct_ctDepth	= ctStack[ctStack_idx][CT_ctDepth],
		uint(size= 8) top_ctDepth	:= cu_top_ctDepth[ct_x0 >> Log2MinCbSize],
		uint(size= 8) left_ctDepth	:= cu_left_ctDepth[ct_y0 >> Log2MinCbSize],
		uint(size= 1) split_cu_flag,
		uint(size= 8) Log2MinCuQpDeltaSize = Log2CtbSize - pps_diff_cu_qp_delta_depth[pps_id],
		uint(size=16) tbX = ( (ct_x0>>Log2MinCbSize) << Log2MinCbSize ) >> Log2CtbSize,
		uint(size=16) tbY = ( (ct_y0>>Log2MinCbSize) << Log2MinCbSize ) >> Log2CtbSize,

		uint(size=16) MinCbAddrZS,
		uint(size=16) m,
		uint(size=16) x0b = ct_x0 & ((1 << Log2CtbSize) - 1),
		uint(size=16) y0b = ct_y0 & ((1 << Log2CtbSize) - 1)
	do
        	qp_block_mask    := (1<<(sps_log2_ctb_size[sps_id] - pps_diff_cu_qp_delta_depth[pps_id])) - 1;
		ct_log2CbSize := ctStack[ctStack_idx][CT_log2CbSize];
		CtbAddrRS := PicWidthInCtbsY * tbY + tbX ;
		MinCbAddrZS := ctbAddrRStoTS[CtbAddrRS] << ((Log2CtbSize - Log2MinCbSize) * 2);
		if DEBUG_CABAC and DEBUG_TRACE1 then
				println("read_CodingTree.start (" + ct_x0 + ", " + ct_y0 + ", " + (1
				<< ct_log2CbSize) + ", " + ctStack[ctStack_idx][CT_ctDepth] + ")");
				elsif DEBUG_CABAC then println("read_CodingTree.start");
		end
		foreach int i in 0 .. Log2CtbSize - Log2MinCbSize - 1 do
			m := 1 << i;
				MinCbAddrZS := MinCbAddrZS + if (m & (ct_x0 >> Log2MinCbSize)) != 0
				then
					m * m
				else
					0
				end + if (m & (ct_y0 >> Log2MinCbSize)) != 0 then
					2 * m * m
				else
					0
				end;
		end
			if (ctb_left_flag) or (x0b > 0) then
			left_ctDepth	:= cu_left_ctDepth[ct_y0 >> Log2MinCbSize];
		end
			if (ctb_up_flag) or (y0b > 0) then
			top_ctDepth	:= cu_top_ctDepth[ct_x0 >> Log2MinCbSize];
		end
		if	ct_x0 + ( 1 << ct_log2CbSize ) <= sps_pic_width_in_luma_samples[sps_id] and
			ct_y0 + ( 1 << ct_log2CbSize ) <= sps_pic_height_in_luma_samples[sps_id] and
			ct_log2CbSize > Log2MinCbSize then
				get_SPLIT_CODING_UNIT_FLAG(codIRange, codIOffset, ctxTable, fifo,
				res, ct_ctDepth, (ctb_left_flag) or (x0b > 0), left_ctDepth,
				(ctb_up_flag) or (y0b > 0), top_ctDepth);
			split_cu_flag := res[0];
		else
				split_cu_flag := if ct_log2CbSize > Log2MinCbSize then
					1
				else
					0
				end;
		end
			if ((pps_cu_qp_delta_enabled_flag[pps_id] != 0) and ct_log2CbSize >=
			Log2MinCuQpDeltaSize) then
			IsCuQpDeltaCoded := 0;
			CuQpDelta        := 0;
		end

		if split_cu_flag = 1 then
			ctStack[ctStack_idx][CT_x1]  := ct_x0 + ( ( 1 << ct_log2CbSize ) >> 1 );
			ctStack[ctStack_idx][CT_y1]  := ct_y0 + ( ( 1 << ct_log2CbSize ) >> 1 );
			ctStack[ctStack_idx][CT_idx] := 2;
		else
			ctStack[ctStack_idx][CT_idx] := 6;
		end
	end

	/**************************************************************************
	 * read_CodingQuadTree.case1
	 *************************************************************************/
	read_CodingQuadTree.case1 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 2
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 3;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x0];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y0];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end

	/**************************************************************************
	 * read_CodingQuadTree.case2
	 *************************************************************************/
	read_CodingQuadTree.case2 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 3,
		ctStack[ctStack_idx][CT_x1] < sps_pic_width_in_luma_samples[sps_id]
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 4;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x1];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y0];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end


	read_CodingQuadTree.noCase2 : action ==> CUInfo:[cuInfo] repeat 5, TileCUInfo:[tilecuInfo] repeat 5,
		 PartMode:[PART_2Nx2N]
	guard
		ctStack[ctStack_idx][CT_idx] = 3,
		ctStack[ctStack_idx][CT_x1] >= sps_pic_width_in_luma_samples[sps_id]
	var
		uint(size=16) tilecuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x1]- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]- rowTileInPix[rowIndex],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)],
		uint(size=16) cuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x1], ctStack[ctStack_idx][CT_y0],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
	do
		ctStack[ctStack_idx][CT_idx]        := 4;
	end
	/**************************************************************************
	 * read_CodingQuadTree.case3
	 *************************************************************************/
	read_CodingQuadTree.case3 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 4,
		ctStack[ctStack_idx][CT_y1] < sps_pic_height_in_luma_samples[sps_id]
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 5;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x0];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y1];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end
	read_CodingQuadTree.noCase3 : action ==> CUInfo:[cuInfo] repeat 5, TileCUInfo:[tilecuInfo] repeat 5,
		 PartMode:[PART_2Nx2N]
	guard
		ctStack[ctStack_idx][CT_idx] = 4,
		ctStack[ctStack_idx][CT_y1] >= sps_pic_height_in_luma_samples[sps_id]
	var
		uint(size=16) tilecuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x0]- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y1]- rowTileInPix[rowIndex],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)],
		uint(size=16) cuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y1],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
	do
		ctStack[ctStack_idx][CT_idx]        := 5;
	end
	/**************************************************************************
	 * read_CodingQuadTree.case4
	 *************************************************************************/
	read_CodingQuadTree.case4 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 5,
		ctStack[ctStack_idx][CT_x1] < sps_pic_width_in_luma_samples[sps_id],
		ctStack[ctStack_idx][CT_y1] < sps_pic_height_in_luma_samples[sps_id]
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 7;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x1];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y1];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end
	read_CodingQuadTree.noCase4 : action ==> CUInfo:[cuInfo] repeat 5, TileCUInfo:[tilecuInfo] repeat 5,
		 PartMode:[PART_2Nx2N]
	guard
		ctStack[ctStack_idx][CT_idx] = 5,
		ctStack[ctStack_idx][CT_x1] >= sps_pic_width_in_luma_samples[sps_id] or
		ctStack[ctStack_idx][CT_y1] >= sps_pic_height_in_luma_samples[sps_id]
	var
		uint(size=16) tilecuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x1]- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y1]- rowTileInPix[rowIndex],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)],
		uint(size=16) cuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x1], ctStack[ctStack_idx][CT_y1],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
	do
		ctStack[ctStack_idx][CT_idx]        := 7;
	end
	/**************************************************************************
	 * read_CodingQuadTree_gotoCodingUnit
	 *************************************************************************/
	read_CodingQuadTree_gotoCodingUnit : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 6
	do
		ctStack[ctStack_idx][CT_idx]        := 7;
		cu_idx			:= 1;
		cu_x0			:= ctStack[ctStack_idx][CT_x0];
		cu_y0			:= ctStack[ctStack_idx][CT_y0];
		cu_log2CbSize	:= ctStack[ctStack_idx][CT_log2CbSize];
		cu_ctDepth		:= ctStack[ctStack_idx][CT_ctDepth];
	end
	/**************************************************************************
	 * read_CodingQuadTree_end
	 *************************************************************************/
	read_CodingQuadTree.noEnd : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 7,
		ctStack_idx != 0
	do
		ctStack_idx := ctStack_idx - 1;
	end
	read_CodingQuadTree_end : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 7,
		ctStack_idx = 0
        do
//        	tab_slice_address[CtbAddrRS] := -1;
			if (((cu_x0 + (1 << cu_log2CbSize)) & qp_block_mask) = 0 && ((cu_y0 + (1 << cu_log2CbSize)) & qp_block_mask) = 0) then // cu_xo and cu_y0 to be checked TODO
        		qPy_pred := qp_y;
        	end
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Coding Unit                          *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) cu_idx;
	uint(size=16) cu_x0;
	uint(size=16) cu_y0;
	uint(size= 8) cu_log2CbSize;
	uint(size= 8) cu_ctDepth;
	uint(size= 8) predMode;
	uint(size= 8) partMode;
	uint(size= 1) IntraSplitFlag;
	uint(size= 8) MaxTrafoDepth;
	uint(size= 1) cu_transquant_bypass_flag;
	uint(size= 8) cu_top_ctDepth[PICT_WIDTH];
	uint(size= 8) cu_left_ctDepth[PICT_WIDTH];
	uint(size= 1) skip_flag;
	uint(size= 1) merge_flag;
	uint(size=6) intraChrPredModIdx;
	uint(size=6) intraPredModeC[5][5] =
		[[34,  0,  0,  0,  0],
		 [26, 34, 26, 26, 26],
		 [10, 10, 34, 10, 10],
		 [ 1,  1,  1, 34,  1],
		 [0, 26, 10, 1, 0]];

		int qp_block_mask := 0;
		/**************************************************************************
	 * read_CodingUnit.start
	 *************************************************************************/
	uint(size= 8) cu_nCbS;
		int counterfillSkip := 0;
	read_CodingUnit.start : action ==>
	guard
		cu_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 8) length 		 = (1 << cu_log2CbSize) >> Log2MinCbSize,
		int(size=32) x_cb                        = cu_x0 >> Log2MinCbSize,
		int(size=32) y_cb                        = cu_y0 >> Log2MinCbSize,

		int(size=32) ct_x0                      = ctStack[ctStack_idx][CT_x0],
				int(size=32) ct_y0                      = ctStack[ctStack_idx][CT_y0],
		int(size=32) x0b = ct_x0 & ((1 << Log2CtbSize) - 1),
		int(size=32) y0b = ct_y0 & ((1 << Log2CtbSize) - 1),
		bool leftFlag,
		bool upFlag
	do
        	qp_block_mask    := (1<<(sps_log2_ctb_size[sps_id] - pps_diff_cu_qp_delta_depth[pps_id])) - 1;
			pcm_flag := 0;
		leftFlag := ctb_left_flag or (x0b > 0);
		upFlag := ctb_up_flag or (y0b > 0);
		skip_flag  := 0;
		merge_flag := 0;
		intra_pred_mode := [1 : for int i in 0 .. 3];
		if DEBUG_CABAC and DEBUG_TRACE1 then
				println("read_CodingUnit.start (" + cu_x0 + ", " + cu_y0 + ", " +
				cu_log2CbSize + ")");
				elsif DEBUG_CABAC then println("read_CodingUnit.start");
		end
		predMode := INTRA;
		if pps_transquant_bypass_enable_flag[pps_id] != 0 then
				get_CU_TRANSQUANT_BYPASS_FLAG(codIRange, codIOffset, ctxTable, fifo,
				res);
			cu_transquant_bypass_flag := res[0];
        		if cu_transquant_bypass_flag != 0 then
        			 set_deblocking_bypass(cu_x0, cu_y0, cu_log2CbSize);
			end
		else
			cu_transquant_bypass_flag := 0;
		end
		if slice_type != I_SLICE then
				get_SKIP_FLAG(codIRange, codIOffset, ctxTable, fifo, res,
				skip_flag_tab, x_cb, y_cb, leftFlag, upFlag);
			skip_flag := res[0];
			predMode := SKIP;
				predMode := if skip_flag = 1 then
					SKIP
				else
					INTER
				end;
			foreach uint i  in 0 .. length-1 do
				skip_flag_tab[x_cb+i][0] := skip_flag;
				skip_flag_tab[y_cb+i][1] := skip_flag;
			end
				counterfillSkip := counterfillSkip + 1;
		end
		cu_nCbS			:= ( 1 << cu_log2CbSize );
		partMode		:= PART_2Nx2N;
		cu_idx := 2;
	end
	/**************************************************************************
	 * read_CodingUnit_gotoPredictionUnit.goto1
	 *************************************************************************/
	read_CodingUnit_gotoPredictionUnit.goto1 : action ==> CUInfo:[cuInfo] repeat 5, TileCUInfo:[tilecuInfo] repeat 5, Cbf :[false],
                 PartMode:[PART_2Nx2N], SplitTransform:[false]
                 , TUSize:[1<<cu_log2CbSize, 1, 0, 0, slice_qp, TEXT_LUMA, 0, //luma
																1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_U, 0,	//cb
																1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_V, 0] //cr
																																
	guard
		cu_idx = 2,
		skip_flag != 0
	var
		uint(size=16) tilecuInfo[5] = [SKIP,
		ctStack[ctStack_idx][CT_x0]- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]- rowTileInPix[rowIndex],
		1<<cu_log2CbSize, 1<<cu_log2CbSize],
		uint(size=16) cuInfo[5] = [SKIP,
		ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
		1<<cu_log2CbSize, 1<<cu_log2CbSize]
	do
		cu_idx		:= 10;
		pu_idx		:= 1;
		pu_PbW		:= cu_nCbS;
		pu_PbH		:= cu_nCbS;
		intra_prediction_unit_default_value( cu_x0, cu_y0, cu_log2CbSize, partMode, Log2MinCbSize-1, intraPredMode);
	end
	/**************************************************************************
	 * read_CodingUnit.noGoto1
	 *************************************************************************/

	uint(size= 8) intra_pred_mode[4];
	uint(size= 8) intra_pred_mode_c;
	read_CodingUnit_noGoto1 : action ==> PartMode:[partMode]
	guard
		cu_idx = 2 and isFifoFull(fifo),
		skip_flag = 0
	var
		uint(size= 1) prev_intra_luma_pred_flag[4],
		uint(size= 8) intra_chroma_table[4] = [0, 26, 10, 1],
		uint(size=32) res[1],
		uint(size= 8) Log2MinIPCMCUSize = Log2MinCbSize,
		uint(size= 8) pbOffset,
		uint(size= 8) pbEnd
	do
		IntraSplitFlag	:= 0;
		if slice_type != I_SLICE then
			//println("codIRangeget_PRED_MODE_FLAG := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
			get_PRED_MODE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			predMode := res[0];
		end
		if predMode != INTRA or cu_log2CbSize = Log2MinCbSize then
			//println("codIRangeget_PART_SIZE := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
			get_PART_SIZE(codIRange, codIOffset, ctxTable, fifo, res, predMode = INTRA, cu_log2CbSize, Log2MinCbSize, amp_enabled_flag);
			partMode := res[0];
			IntraSplitFlag := if ((partMode=PART_NxN) and (predMode=INTRA)) then 1 else 0 end;
		end
		cu_idx := 4;
		if( predMode = INTRA ) then
			pcm_flag := 0;
			if  partMode = PART_2Nx2N and sps_pcm_enabled_flag[sps_id] = 1 and
								cu_log2CbSize >= log2_min_pcm_cb_size[sps_id] and
								cu_log2CbSize <= log2_max_pcm_cb_size[sps_id] then
				//println("codIRangePCMFlag := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
				get_PCM_FLAG(codIRange, codIOffset, fifo, res);
                                pcm_flag := res[0];
			end
                        if( pcm_flag != 0) then
                                //byte_align(fifo);
				intra_prediction_unit_default_value( cu_x0, cu_y0, cu_log2CbSize, partMode, Log2MinCbSize-1, intraPredMode);
				cu_idx := 3;
			else
				pbOffset := if partMode = PART_NxN then cu_nCbS>>1 else cu_nCbS end;
				pbEnd    := if partMode = PART_NxN then 1 else 0 end;
				foreach int i in 0 .. pbEnd do
					foreach int j in 0 .. pbEnd do
						get_PREV_INTRA_LUMA_PRED_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
						prev_intra_luma_pred_flag[ (i<<1) + j ] := res[0];
					end
				end
				foreach int i in 0 .. pbEnd do
					foreach int j in 0 .. pbEnd do
						if prev_intra_luma_pred_flag[ (i<<1) + j ] = 1 then
							get_MPM_IDX(codIRange, codIOffset, fifo, res);
						else
							get_REM_INTRA_LUMA_PRED_MODE(codIRange, codIOffset, fifo, res);
						end

												luma_intra_pred_mode(cu_x0 + j*pbOffset, cu_y0 + i*pbOffset, pbOffset, prev_intra_luma_pred_flag[ (i<<1) + j ], res[0], res, Log2MinIPCMCUSize-1 ,Log2CtbSize, intraPredMode, ctb_up_flag, ctb_left_flag);
						intra_pred_mode[ (i<<1) + j ] := res[0];
					end
				end
				get_INTRA_CHROMA_PRED_MODE(codIRange, codIOffset, ctxTable, fifo, res);
				intraChrPredModIdx := res[0];
				if res[0] != 4 then
					if intra_pred_mode[0] = intra_chroma_table[res[0]] then
						intra_pred_mode_c := 34;
					else
						intra_pred_mode_c := intra_chroma_table[res[0]];
					end
				else
					intra_pred_mode_c := intra_pred_mode[0];
				end
				cu_idx := 8;
			end
		else
			intra_prediction_unit_default_value( cu_x0, cu_y0, cu_log2CbSize, partMode, Log2MinCbSize-1, intraPredMode);
		end
	end

	sendIntraPredMode.skip: action ==>
	guard
		predMode != INTRA
	end

	sendIntraPredMode.part2Nx2N: action ==> IntraPredMode:[intra_pred_mode[0], predMode_v], CUInfo:[cuInfo] repeat 5,  TileCUInfo:[tilecuInfo] repeat 5
	guard
		partModeToNumPart[partMode] = 1 and predMode = INTRA
	var
		uint(size=16) tilecuInfo[5] =
			[predMode, ctStack[ctStack_idx][CT_x0]- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]- rowTileInPix[rowIndex],
				1<<cu_log2CbSize, 1<<cu_log2CbSize],
		uint(size=16) cuInfo[5] =
			[predMode, ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
				1<<cu_log2CbSize, 1<<cu_log2CbSize],
		uint(size=6) predMode_v,
		uint(size=3) idx
	do
		if(intraChrPredModIdx=4) then
			predMode_v := intra_pred_mode[0];
		else
			idx :=
				if(intra_pred_mode[0] = 0) then
					0
				elsif(intra_pred_mode[0] = 26) then
					1
				elsif(intra_pred_mode[0] = 10) then
					2
				elsif(intra_pred_mode[0] = 1) then
					3
				else
					4
				end;
			predMode_v := intraPredModeC[intraChrPredModIdx][idx];
		end
	end

	sendIntraPredMode.partNxN: action ==> IntraPredMode:[intraPredMode] repeat 8, CUInfo:[cuInfo] repeat 20, TileCUInfo:[tilecuInfo] repeat 20
	guard
		partModeToNumPart[partMode] != 1 and predMode = INTRA
	var
		uint(size=7) CUSize = (1<<(cu_log2CbSize-1)),
		uint(size=16) tilecuInfo[20] =
			[predMode, ctStack[ctStack_idx][CT_x0]       - colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]       - rowTileInPix[rowIndex], CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]+CUSize- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]       - rowTileInPix[rowIndex], CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]       - colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]+CUSize- rowTileInPix[rowIndex], CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]+CUSize- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]+CUSize- rowTileInPix[rowIndex], CUSize, CUSize],
		uint(size=16) cuInfo[20] =
			[predMode, ctStack[ctStack_idx][CT_x0]       , ctStack[ctStack_idx][CT_y0]       , CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]+CUSize, ctStack[ctStack_idx][CT_y0]       , CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]       , ctStack[ctStack_idx][CT_y0]+CUSize, CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]+CUSize, ctStack[ctStack_idx][CT_y0]+CUSize, CUSize, CUSize],
		uint(size=6) intraPredMode[8],
		uint(size=3) idx
	do
		foreach uint i in 0 .. 3
		do
			intraPredMode[2*i] := intra_pred_mode[i];

			if(intraChrPredModIdx=4) then
				intraPredMode[2*i+1] := intra_pred_mode[i];
			else
				idx :=
					if(intra_pred_mode[i] = 0) then
						0
					elsif(intra_pred_mode[i] = 26) then
						1
					elsif(intra_pred_mode[i] = 10) then
						2
					elsif(intra_pred_mode[i] = 1) then
						3
					else
						4
					end;
				intraPredMode[2*i+1] := intraPredModeC[intraChrPredModIdx][idx];
			end
		end
	end

	/**************************************************************************
	 * read_CodingUnit_gotoPCMSample
	 *************************************************************************/
	read_CodingUnit_gotoPCMSample : action ==>
	guard
		cu_idx = 3
	do
		cu_idx				 := 8;
	end
	/**************************************************************************
	 * read_CodingUnit_gotoPredictionUnit.goto2
	 *************************************************************************/
	read_CodingUnit_gotoPredictionUnit.goto2 : action ==> TileCUInfo:[predMode, x0- colTileInPix[colIndex], y0- rowTileInPix[rowIndex], pu_PbW, pu_PbH],
	CUInfo:[predMode, x0, y0, pu_PbW, pu_PbH]
	guard
		cu_idx = 4 or cu_idx = 5 or
		cu_idx = 6 or cu_idx = 7
	var
		uint(size= 8) nCbS_2   = cu_nCbS >> 1,
		uint(size= 8) nCbS_4   = cu_nCbS >> 2,
		uint(size= 8) nCbS_3_4 = cu_nCbS - nCbS_4,
		int x0 := ctStack[ctStack_idx][CT_x0],
		int y0 := ctStack[ctStack_idx][CT_y0]
	do
		pu_idx := 1;
		pu_PbW := cu_nCbS;
		pu_PbH := cu_nCbS;
		if partMode = PART_2Nx2N then
			//prediction_unit( x0, y0, nCbS, nCbS )
			cu_idx    := 8;
		elsif partMode = PART_2NxN then
			pu_PbH := nCbS_2;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS, nCbS / 2 )
				cu_idx := 5;
			else
				//prediction_unit( x0, y0 + ( nCbS / 2 ), nCbS, nCbS / 2 )
				cu_idx := 8;
				y0 := y0  + nCbS_2;
			end
		elsif partMode = PART_Nx2N then
			pu_PbW := nCbS_2;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS / 2, nCbS )
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS / 2 ), y0, nCbS / 2, nCbS )
				cu_idx := 8;
				x0 := x0 + nCbS_2;
			end
		elsif partMode = PART_2NxnU then
			pu_PbH := nCbS_4;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS, nCbS / 4 )
				cu_idx := 5;
			else
				//prediction_unit( x0, y0 + ( nCbS / 4 ), nCbS, nCbS *3 / 4 )
				pu_PbH := nCbS_3_4;
				cu_idx := 8;
				y0 := y0  + nCbS_4;
			end
		elsif partMode = PART_2NxnD then
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS, nCbS *3 / 4 )
				pu_PbH := nCbS_3_4;
				cu_idx := 5;
			else
				//prediction_unit( x0, y0 + ( nCbS * 3 / 4 ), nCbS, nCbS / 4 )
				pu_PbH := nCbS_4;
				cu_idx := 8;
				y0 := y0  + nCbS_3_4;
			end
		elsif partMode = PART_nLx2N then
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS /4, nCbS )
				pu_PbW := nCbS_4;
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS / 4 ), y0, nCbS *3 / 4, nCbS)
				pu_PbW := nCbS_3_4;
				x0 := x0  + nCbS_4;
				cu_idx := 8;
			end
		elsif partMode = PART_nRx2N then
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS *3 / 4, nCbS )
				pu_PbW := nCbS_3_4;
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS * 3 / 4 ), y0, nCbS / 4, nCbS )
				pu_PbW := nCbS_4;
				x0 := x0  + nCbS_3_4;
				cu_idx := 8;
			end
		else /* PART_NxN */
			pu_PbW := nCbS_2;
			pu_PbH := nCbS_2;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS / 2, nCbS / 2)
				cu_idx := 5;
			elsif cu_idx = 5 then
				//prediction_unit( x0 + ( nCbS / 2 ), y0, nCbS / 2, nCbS / 2 )
				x0 := x0  + nCbS_2;
				cu_idx := 6;
			elsif cu_idx = 6 then
				//prediction_unit( x0, y0 + ( nCbS / 2 ), nCbS / 2, nCbS / 2 )
				y0 := y0  + nCbS_2;
                                cu_idx := 7;
			else
				//prediction_unit( x0 + ( nCbS / 2 ), y0 + ( nCbS / 2 ), nCbS / 2, nCbS / 2 )
				x0 := x0  + nCbS_2;
				y0 := y0  + nCbS_2;
				cu_idx := 8;
			end
		end
	end
	/**************************************************************************
	 * read_CodingUnit.endFunction
	 *************************************************************************/
	read_CodingUnit.endFunction : action ==>
	guard
                cu_idx = 8 and isFifoFull(fifo)
	var
		uint(size=32) res[1] := [1]
	do
		cu_idx := 10;
		if pcm_flag = 0 then
			if( predMode != INTRA and not(partMode = PART_2Nx2N and merge_flag = 1) ) then
                		get_NO_RESIDUAL_SYNTAX_FLAG(codIRange, codIOffset, ctxTable,
                		fifo, res); //no_residual_data_flag
			end
			if res[0] != 0 then
				MaxTrafoDepth := if predMode = INTRA then
                			sps_max_transform_hierarchy_depth_intra[sps_id] +
                			IntraSplitFlag
								else
									sps_max_transform_hierarchy_depth_inter[sps_id]
								end;
                		cu_idx := 9; //transform_tree( x0, y0, x0, y0, x0, y0, log2CbSize, log2CbSize, log2CbSize, 0, 0 )
			elsif predMode != INTRA then // ### not conform to openhevc !
				cu_idx	:= 11;
			end
		end
                
	end

	read_CodingUnit.endFunctionSend : action ==> SplitTransform:[false], TUSize:[1<<cu_log2CbSize, 1, 0, 0, slice_qp, TEXT_LUMA, 0, //luma
																1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_U, 0,	//cb
																1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_V, 0], //cr
																																Cbf:[false]
	guard
		cu_idx = 11
	do
        	//println("endFunctionSend");
		cu_idx	:= 10;
	end

	/**************************************************************************
	 * read_CodingUnit_gotoTransformTree
	 *************************************************************************/
	read_CodingUnit_gotoTransformTree : action ==>
	guard
		cu_idx = 9
	do
		cu_idx							:= 10;
		ttStack_idx						:=  0;
		ttStack[0][TT_idx]				:=  1;
		ttStack[0][TT_x0]				:=  cu_x0;
		ttStack[0][TT_y0]				:=  cu_y0;
		ttStack[0][TT_xBase]			:=  cu_x0;
		ttStack[0][TT_yBase]			:=  cu_y0;
		ttStack[0][TT_log2TrafoSize]	:=  cu_log2CbSize;
		ttStack[0][TT_trafoDepth]		:=  0;
		ttStack[0][TT_blkIdx]			:=  0;
	end
	/**************************************************************************
	 * read_CodingUnit_end
	 *************************************************************************/
    procedure set_qPy()
    var
    	int ctb_size_mask        := (1 << Log2CtbSize) - 1,
	    int MinCuQpDeltaSizeMask := (1 << (Log2CtbSize - pps_diff_cu_qp_delta_depth[pps_id])) - 1,
	    int xQgBase              := cu_x0 - (cu_x0 & MinCuQpDeltaSizeMask),
	    int yQgBase              := cu_y0 - (cu_y0 & MinCuQpDeltaSizeMask),
	    int x_cb                 := xQgBase >> Log2MinCbSize,
	    int y_cb                 := yQgBase >> Log2MinCbSize,
	    int availableA           := if ((cu_x0   & ctb_size_mask) != 0 and (xQgBase & ctb_size_mask) != 0) then 1 else 0 end,
	    int availableB           := if (cu_y0   & ctb_size_mask) != 0 and (yQgBase & ctb_size_mask) != 0 then 1 else 0 end,
        int qPy_local 			 := 0,
        int qPy_a 				 := 0,
		int qPy_b 				 := 0,
		int local_qPy_pred		 :=0
    begin
    	if first_qp_group != 0 or (xQgBase = 0 and yQgBase = 0) then
    		first_qp_group := if IsCuQpDeltaCoded != 0 then
    			0
    		else
    			1
    		end;
    		local_qPy_pred := slice_qp;
    	else
    		local_qPy_pred := qPy_pred;
    	end
		
    	if (availableA = 0) then
    		qPy_a := local_qPy_pred;
    	else
    		qPy_a := qp_y_tab[(x_cb - 1) + y_cb * min_cb_width];
    		
    	end
    	
    	if (availableB = 0) then
    		qPy_b := local_qPy_pred;
    	else
    		qPy_b := qp_y_tab[x_cb + (y_cb - 1) * min_cb_width];
    	end
    	qPy_local := (qPy_a + qPy_b + 1) >> 1;
    	if CuQpDelta != 0 then
    		qp_y := ((qPy_local + CuQpDelta + 52 + 2 * qp_bd_offset_luma) mod
    		(52 + qp_bd_offset_luma)) - qp_bd_offset_luma;
    	else
    		qp_y := qPy_local;
    	end
    end
    
    int qPy_pred := 0;
    uint(size= 8) length;
        
	read_CodingUnit_end : action ==>
	guard
		 cu_idx = 10
	var
            uint(size=16) ct_x_cb = cu_x0 >> Log2MinCbSize,
        	uint(size=16) ct_y_cb = cu_y0 >> Log2MinCbSize,
			int x := 0
		do
			length := (1 << cu_log2CbSize) >> Log2MinCbSize;
	        if (pps_cu_qp_delta_enabled_flag[pps_id] != 0 and IsCuQpDeltaCoded = 0)then
	        	set_qPy();
	       	end
	       	//println("read_CodingUnit_end => qp_y = "+ qp_y);
	       	x := ct_y_cb * min_cb_width + ct_x_cb;
        	foreach int y in 0 .. length - 1 do
        		foreach int i in 0 .. length - 1 do
        			qp_y_tab[x + i] := qp_y;
        		end
        		x := x + min_cb_width;
        	end
        	if (((cu_x0 + (1 << cu_log2CbSize)) & qp_block_mask) = 0 && ((cu_y0 + (1 << cu_log2CbSize)) & qp_block_mask) = 0) then // cu_xo and cu_y0 to be checked TODO
        		qPy_pred := qp_y;
        	end
		foreach uint i  in 0 .. length-1 do
	        	cu_top_ctDepth[ct_x_cb + i] := cu_ctDepth;
	        	cu_left_ctDepth[ct_y_cb + i] := cu_ctDepth;
		end
	end
	
	read_CodingUnit_end_sendQp.blk4x4 : action ==> Qp:[qp_y]
    guard
    	length = 0
    end
    
    read_CodingUnit_end_sendQp.blk8x8 : action ==> Qp:[ [ qp_y : for int k in 0 .. 3 ] ] repeat 4
    guard
    	length = 1
    end
    
    read_CodingUnit_end_sendQp.blk16x16 : action ==> Qp:[ [ qp_y : for int k in 0 .. 15 ] ] repeat 16
    guard
    	length = 2
    end
    
    read_CodingUnit_end_sendQp.blk32x32 : action ==> Qp:[ [ qp_y : for int k in 0 .. 63 ] ] repeat 64
    guard
    	length = 4
    end
    
    read_CodingUnit_end_sendQp.blk64x64 : action ==> Qp:[ [ qp_y : for int k in 0 .. 255 ] ] repeat 256
    guard
    	length = 8
    end

	/**************************************************************************
	 **************************************************************************
	 ********        Prediction Unit                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) pu_idx;
	uint(size= 8) pu_PbW;
	uint(size= 8) pu_PbH;
	uint(size= 1) pcm_flag;
	uint(size= 2) inter_pred_idc;
	 int(size=16) mergeIdx;
	 int(size=16) mvp_lx[2];
	 int(size=16) ref_idx_lx[2];
	 int(size=16) mvd[4];

	/**************************************************************************
	 * read_PredictionUnit.start
	 *************************************************************************/
	read_PredictionUnit.start : action ==>
	guard
		isFifoFull(fifo),
		pu_idx = 1
	var
		uint(size=32) res[1]
	do
		inter_pred_idc	:= PRED_L0;
		mergeIdx		:= -1;
		mvp_lx			:= [-1, -1];
		ref_idx_lx		:= [-1, -1];
		mvd				:= [0, 0, 0, 0];
		mvd_x			:= 0;
		mvd_y			:= 0;
		if ( skip_flag = 1) then
			if( MaxNumMergeCand > 1 ) then
					get_MERGE_IDX(codIRange, codIOffset, ctxTable, fifo, res,
					MaxNumMergeCand);
				mergeIdx := res[0];
				else
					mergeIdx := 0;
			end
			pu_idx := 7;
			else

			/* MODE_INTER */
			get_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			merge_flag := res[0];
			if res[0] = 1 then
				if MaxNumMergeCand > 1 then
						get_MERGE_IDX(codIRange, codIOffset, ctxTable, fifo, res,
						MaxNumMergeCand);
					mergeIdx := res[0];
					else
						mergeIdx := 0;
				end
				pu_idx := 7;
			else
				if( slice_type = B_SLICE ) then
						get_INTER_PRED_IDC(codIRange, codIOffset, ctxTable, fifo,
						res, partMode, pu_PbW, pu_PbH, cu_ctDepth);
					inter_pred_idc := res[0];
				end
				if( inter_pred_idc != PRED_L1 ) then
					ref_idx_lx[0] := 0;
					if( num_ref_idx_l0_active > 1 ) then
							get_REF_IDX_LX(codIRange, codIOffset, ctxTable, fifo, res,
							num_ref_idx_l0_active - 1);
						ref_idx_lx[0] := res[0];
						end // goto mvd_coding
					pu_idx := 3;
				else
					pu_idx := 4;
				end
			end
		end
	end
	/**************************************************************************
	 * read_PredictionUnit.retMVDcoding_goto1
	 *************************************************************************/
	read_PredictionUnit.retMVDcoding_goto1 : action ==>
	guard
                pu_idx = 4 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		mvd[0]	:= mvd_x;
		mvd[1]	:= mvd_y;
		mvd_x	:= 0;
		mvd_y	:= 0;
		if( inter_pred_idc != PRED_L1 ) then
			get_MVP_LX_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			mvp_lx[0] := res[0];
		end
		pu_idx := 7;
		if( inter_pred_idc != PRED_L0 ) then
			ref_idx_lx[1] := 0;
			if( num_ref_idx_l1_active > 1 ) then
				get_REF_IDX_LX(codIRange, codIOffset, ctxTable, fifo, res, num_ref_idx_l1_active-1);
				ref_idx_lx[1] := res[0];
			end
			if( mvd_l1_zero_flag = 1 and inter_pred_idc = BI_PRED ) then
				//mvd_l1[ x0 ][ y0 ][ 0 ] = 0
				//mvd_l1[ x0 ][ y0 ][ 1 ] = 0
				pu_idx := 6;
			else
				pu_idx := 5;
			end
		end
	end
	/**************************************************************************
	 * read_PredictionUnit_gotoMVDCoding
	 *************************************************************************/
	read_PredictionUnit_gotoMVDCoding : action ==>
	guard
		pu_idx = 3 or pu_idx = 5
	do
		pu_idx := pu_idx + 1;
	end
	/**************************************************************************
	 * read_PredictionUnit.retMVDcoding_goto2
	 *************************************************************************/
	read_PredictionUnit.retMVDcoding_goto2 : action ==>
	guard
                pu_idx = 6 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		mvd[2] := mvd_x;
		mvd[3] := mvd_y;
		get_MVP_LX_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
		mvp_lx[1] := res[0];
		pu_idx := 7;
	end
	/**************************************************************************
	 * read_PredictionUnit_end
	 *************************************************************************/
	read_PredictionUnit_end.mergeIdx_Eq_min1 : action ==> MvPredSyntaxElem:[mergeIdx,
															mvp_lx[0]     , mvp_lx[1],
															ref_idx_lx[0] , ref_idx_lx[1],
															mvd[0], mvd[1], mvd[2], mvd[3]]
	guard
		pu_idx = 7, mergeIdx = -1
	end
	read_PredictionUnit_end.mergeIdx_notEq_min1 : action ==> MvPredSyntaxElem:[mergeIdx,
															mvd[0], mvd[1], mvd[2], mvd[3]]
	guard
		pu_idx = 7, mergeIdx != -1
	end
	/**************************************************************************
	 **************************************************************************
	 ********        MVD Coding                           *********************
	 **************************************************************************
	 *************************************************************************/
	 int(size=32) mvd_x;
	 int(size=32) mvd_y;
	 uint(size= 1) abs_mvd_greater1_flag_1;
	 uint(size= 1) abs_mvd_greater0_flag_1;


	read_MVDCoding.start : action ==>
	guard
		isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) abs_mvd_greater0_flag_0,
		uint(size= 1) abs_mvd_greater1_flag_0,
		 int(size=16) abs_mvd_minus2_0 := 0,
		uint(size= 1) mvd_sign_flag_0  := 0
	do
		get_ABS_MVD_GREATER0_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
		abs_mvd_greater0_flag_0 := res[0];
		get_ABS_MVD_GREATER0_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
		abs_mvd_greater0_flag_1 := res[0];
		if abs_mvd_greater0_flag_0 = 1 then
			get_ABS_MVD_GREATER1_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			abs_mvd_greater1_flag_0 := res[0];
		end
		if abs_mvd_greater0_flag_1 = 1 then
		get_ABS_MVD_GREATER1_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			abs_mvd_greater1_flag_1 := res[0];
		end
		if abs_mvd_greater0_flag_0 = 1 then
			abs_mvd_minus2_0 := -1;
			if abs_mvd_greater1_flag_0 = 1 then
				get_ABS_MVD_MINUS2(codIRange, codIOffset, fifo, res);
				abs_mvd_minus2_0 := res[0];
			end
			get_MVD_SIGN_FLAG(codIRange, codIOffset, fifo, res);
			mvd_sign_flag_0 := res[0];
		end
		mvd_x := abs_mvd_greater0_flag_0 * ( abs_mvd_minus2_0 + 2 ) * ( 1 - (mvd_sign_flag_0 << 1) );
	end

	read_MVDCoding.ended : action ==>
	guard
		isFifoFull(fifo)
	var
		uint(size=32) res[1],
		 int(size=16) abs_mvd_minus2_1 := 0,
		uint(size= 1) mvd_sign_flag_1  := 0
	do
		if abs_mvd_greater0_flag_1 = 1 then
			abs_mvd_minus2_1 := -1;
			if abs_mvd_greater1_flag_1 = 1 then
				get_ABS_MVD_MINUS2(codIRange, codIOffset, fifo, res);
				abs_mvd_minus2_1 := res[0];
			end
			get_MVD_SIGN_FLAG(codIRange, codIOffset, fifo, res);
			mvd_sign_flag_1 := res[0];
		end
		mvd_y := abs_mvd_greater0_flag_1 * ( abs_mvd_minus2_1 + 2 ) * ( 1 - (mvd_sign_flag_1 << 1) );
	end

	/**************************************************************************
	 **************************************************************************
	 ********        PCM Sample                           *********************
	 **************************************************************************
	 *************************************************************************/
		uint(size=8) pcm_sample_luma[4096]; // TODO size to be checked !!
		uint(size=8) pcm_sample_chroma[4096];// TODO size to be checked !!
		uint(size=8) is_pcm[4096];// TODO size to be checked !!
		int pcm_skip_length;

        read_PCMSample_start : action ==>
	var
                int cb_size = 1 << cu_log2CbSize,
                int length
	do
		if DEBUG_CABAC then
			println("read_PCMSample");
		end
        		length := cb_size * cb_size * pcm_bit_depth[sps_id] + ((cb_size * cb_size) >> 1) * pcm_bit_depth_chroma[sps_id];
        		pcm_skip_length := (length + 7) >> 3;
        		cnt_i := 0;
       end
       read_PCMSample_skipLoop : action ==>
       guard
       		cnt_i < pcm_skip_length, isFifoFull(fifo)
       do
       		flushBits(8, fifo); // skipbyte
       		cnt_i := cnt_i + 1;
       end
       read_PCMSample_skipLoop_end : action ==>
       guard
       		cnt_i = pcm_skip_length, isFifoFull(fifo)
       do
       		cnt_i := 0;
            decodeReInit(codIRange, codIOffset, fifo);
            //ret = init_get_bits(&gb, pcm, length); TODO !!
            
            foreach int i  in 0 .. 1 << ( cu_log2CbSize ) do
                    //vld_u_name(  1, fifo, res, "pcm_sample_luma[i]                      ");
                    pcm_sample_luma[ i ] := pcm_bit_depth[sps_id];
            end
            foreach int i  in 0 .. 1 << ( cu_log2CbSize << 1 ) do
                    //vld_u_name(  1, fifo, res, "pcm_sample_chroma[i]                    ");
                    pcm_sample_chroma[ i ] := pcm_bit_depth_chroma[sps_id];
            end
        	if (pcm_loop_filter_disable_flag[sps_id] != 0) then
                    set_deblocking_bypass(cu_x0, cu_y0, cu_log2CbSize);
            end
        end
        
        procedure set_deblocking_bypass (uint (size=16) x0, uint (size=16) y0, uint (size=8) logSize)
        var
        	int min_pu_width     = sps_min_pu_width[sps_id],
    		int x_end = min(x0 + logSize, sps_pic_width_in_luma_samples[sps_id]),
    		int y_end = min(y0 + logSize, sps_pic_height_in_luma_samples[sps_id])
    	begin
    		foreach int j in (y0 >> sps_log2_min_pu_size[sps_id]) .. (y_end >> sps_log2_min_pu_size[sps_id]) - 1 do
    			foreach int i in (x0 >> sps_log2_min_pu_size[sps_id]) .. (x_end >> sps_log2_min_pu_size[sps_id]) - 1 do
    				is_pcm[i + j * min_pu_width] := 2;
    			end
		end
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Transform Tree                       *********************
	 **************************************************************************
	 *************************************************************************/

	uint(size= 8) ttStack_idx;
	uint(size=16) ttStack[10][TT_STRUCT_SIZE];
	uint(size= 1) cbf_cb[MAX_TU_SIZE][MAX_TU_SIZE][4];
	uint(size= 1) cbf_cr[MAX_TU_SIZE][MAX_TU_SIZE][4];
	uint(size= 1) cbf_luma;
	uint(size= 8) cur_intra_pred_mode;
	uint(size= 1) split_transform_flag;
		uint(size=16) cbf_xBase;
		uint(size=16) cbf_yBase;

	/**************************************************************************
	 * read_TransformTree.start
	 *************************************************************************/
	read_TransformTree.start : action ==>
	guard
		isFifoFull(fifo),
		ttStack[ttStack_idx][TT_idx] = 1
	var
		uint(size=16) x0				= ttStack[ttStack_idx][TT_x0],
		uint(size=16) y0				= ttStack[ttStack_idx][TT_y0],
		uint(size=16) xBase				= ttStack[ttStack_idx][TT_xBase],
		uint(size=16) yBase				= ttStack[ttStack_idx][TT_yBase],
		uint(size= 8) log2TrafoSize	    = ttStack[ttStack_idx][TT_log2TrafoSize],
		uint(size= 8) trafoDepth		= ttStack[ttStack_idx][TT_trafoDepth],
		uint(size=16) cbf_x0			= x0 & ((1<<log2TrafoSize)-1),
		uint(size=16) cbf_y0			= y0 & ((1<<log2TrafoSize)-1),
		uint(size=32) res[1] := [0],
		uint(size= 1) IntraSplitFlag   = if predMode = INTRA and partMode = PART_NxN then 1 else 0 end,
		uint(size= 1) InterSplitFlag   = if sps_max_transform_hierarchy_depth_inter[sps_id] = 0 and predMode = INTER and partMode != PART_2Nx2N and trafoDepth = 0 then 1 else 0 end
	do
			cbf_xBase := xBase & ((1 << log2TrafoSize) - 1);
			cbf_yBase := yBase & ((1 << log2TrafoSize) - 1);
		if DEBUG_CABAC and DEBUG_TRACE1 then
				println("read_TransformTree.start(" + x0 + ", " + y0 + ", " + xBase
				+ ", " + yBase + ", " + log2TrafoSize + ", " + trafoDepth + ", " +
				ttStack[ttStack_idx][TT_blkIdx] + ")");
				elsif DEBUG_CABAC then println("read_TransformTree.start");
		end
		if IntraSplitFlag = 1 then
			if trafoDepth = 1 then
					cur_intra_pred_mode :=
					intra_pred_mode[ttStack[ttStack_idx][TT_blkIdx]];
			end
		else
			cur_intra_pred_mode := intra_pred_mode[0];
		end
		split_transform_flag := 0;
			if (log2TrafoSize <= Log2MaxTrafoSize and log2TrafoSize >
			Log2MinTrafoSize and trafoDepth < MaxTrafoDepth and
			not(IntraSplitFlag = 1 and trafoDepth = 0)) then
				get_SPLIT_TRANSFORM_FLAG(codIRange, codIOffset, ctxTable, fifo,
				res, log2TrafoSize);
			split_transform_flag := res[0];
				elsif log2TrafoSize > Log2MaxTrafoSize or (IntraSplitFlag = 1 and
				trafoDepth = 0) or InterSplitFlag = 1 then split_transform_flag :=
				1;
		end
		cbf_cb[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := 0;
		cbf_cr[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := 0;
		if trafoDepth = 0 or log2TrafoSize > 2  then
			if trafoDepth = 0 then
					get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res,
					trafoDepth);
				cbf_cb[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := res[0];
					get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res,
					trafoDepth);
				cbf_cr[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := res[0];
			else
				if cbf_cb[ cbf_xBase ][ cbf_yBase ][ trafoDepth-1 ] = 1 then
						get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res,
						trafoDepth);
					cbf_cb[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := res[0];
				end
				if cbf_cr[ cbf_xBase ][ cbf_yBase ][ trafoDepth-1 ] = 1 then
						get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res,
						trafoDepth);
					cbf_cr[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := res[0];
				end
			end
		end
		if trafoDepth > 0 and log2TrafoSize = 2  then
				cbf_cb[cbf_x0][cbf_y0][trafoDepth] :=
				cbf_cb[cbf_xBase][cbf_yBase][trafoDepth - 1];
				cbf_cr[cbf_x0][cbf_y0][trafoDepth] :=
				cbf_cr[cbf_xBase][cbf_yBase][trafoDepth - 1];
		end
		if split_transform_flag = 1 then
			ttStack[ttStack_idx][TT_x1]  := x0 + ( ( 1 << log2TrafoSize ) >> 1 );
			ttStack[ttStack_idx][TT_y1]  := y0 + ( ( 1 << log2TrafoSize ) >> 1 );
			ttStack[ttStack_idx][TT_idx] := 3;
		else
			cbf_luma := 1;
			if predMode = INTRA or trafoDepth != 0 or
				cbf_cb[cbf_x0][cbf_y0][trafoDepth] = 1 or
				cbf_cr[cbf_x0][cbf_y0][trafoDepth] = 1 then
					get_CBF_LUMA(codIRange, codIOffset, ctxTable, fifo, res,
					trafoDepth);
				cbf_luma := res[0];
			end
			ttStack[ttStack_idx][TT_idx] := 2;
		end
			if not(partMode = PART_NxN and ttStack[ttStack_idx][TT_trafoDepth] =
			0) then
			ttStack[ttStack_idx][TT_idx] := 10;
		end
	end

	read_TransformTree.start_nonPartNxN : action ==> SplitTransform:[(split_transform_flag != 0)]
	guard
		ttStack[ttStack_idx][TT_idx] = 10
	do
		ttStack[ttStack_idx][TT_idx] := 2 + split_transform_flag;
	end
	/**************************************************************************
	 * read_TransformTree_gotoTransformUnit
	 *************************************************************************/
	read_TransformTree_gotoTransformUnit : action ==> Cbf:[cbf_luma = 1]
	guard
		ttStack[ttStack_idx][TT_idx] = 2
	do
		ttStack[ttStack_idx][TT_idx]	:= 7;
		tu_idx							:= 1;
		tu_x0							:= ttStack[ttStack_idx][TT_x0];
		tu_y0							:= ttStack[ttStack_idx][TT_y0];
		tu_xBase						:= ttStack[ttStack_idx][TT_xBase];
		tu_yBase						:= ttStack[ttStack_idx][TT_yBase];
		tu_log2TrafoSize				:= ttStack[ttStack_idx][TT_log2TrafoSize];
		tu_trafoDepth					:= ttStack[ttStack_idx][TT_trafoDepth];
		tu_blkIdx						:= ttStack[ttStack_idx][TT_blkIdx];
	end
	/**************************************************************************
	 * read_TransformTree.gotoTransformTree
	 *************************************************************************/
	read_TransformTree.gotoTransformTree : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 3 or ttStack[ttStack_idx][TT_idx] = 4 or
		ttStack[ttStack_idx][TT_idx] = 5 or ttStack[ttStack_idx][TT_idx] = 6
	var
		uint(size= 8) idx = ttStack_idx
	do
		ttStack[ttStack_idx][TT_idx]				:= ttStack[ttStack_idx][TT_idx] + 1;
		ttStack_idx 								:= ttStack_idx + 1;
		ttStack[ttStack_idx][TT_idx]				:= 1;
		ttStack[ttStack_idx][TT_x0]					:= ttStack[idx][TT_x0];
		ttStack[ttStack_idx][TT_y0]					:= ttStack[idx][TT_y0];
		ttStack[ttStack_idx][TT_xBase]				:= ttStack[idx][TT_x0];
		ttStack[ttStack_idx][TT_yBase]				:= ttStack[idx][TT_y0];
		ttStack[ttStack_idx][TT_log2TrafoSize]		:= ttStack[idx][TT_log2TrafoSize] - 1;
		ttStack[ttStack_idx][TT_trafoDepth]			:= ttStack[idx][TT_trafoDepth] + 1;
		if ttStack[idx][TT_idx] = 4 then
			ttStack[ttStack_idx][TT_blkIdx]			:= 0;
		elsif ttStack[idx][TT_idx] = 5 then
			ttStack[ttStack_idx][TT_x0]		    	:= ttStack[idx][TT_x1];
			ttStack[ttStack_idx][TT_blkIdx]			:= 1;
		elsif ttStack[idx][TT_idx] = 6 then
			ttStack[ttStack_idx][TT_y0]				:= ttStack[idx][TT_y1];
			ttStack[ttStack_idx][TT_blkIdx]			:= 2;
		else
			ttStack[ttStack_idx][TT_x0]				:= ttStack[idx][TT_x1];
			ttStack[ttStack_idx][TT_y0]				:= ttStack[idx][TT_y1];
			ttStack[ttStack_idx][TT_blkIdx]			:= 3;
		end
	end
	/**************************************************************************
	 * read_TransformTree_end
	 *************************************************************************/
	read_TransformTree_end : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 7 and ttStack_idx = 0
	end
	read_TransformTree.endCall : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 7 and ttStack_idx != 0
	do
		ttStack_idx := ttStack_idx - 1;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Transform Unit                       *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) tu_idx;
	uint(size=16) tu_x0;
	uint(size=16) tu_y0;
	uint(size=16) tu_xBase;
	uint(size=16) tu_yBase;
	uint(size= 8) tu_trafoDepth;
	uint(size= 8) tu_blkIdx;
	uint(size= 8) tu_log2TrafoSize;
        int qp_y_tab [4096 * 2048]; // to be checked

	/**************************************************************************
	 * read_TransformUnit.start
	 *************************************************************************/
	read_TransformUnit.start : action ==>
	guard
		isFifoFull(fifo),
		tu_idx = 1
	var
		uint(size=32) res[1] := [0],
                uint(size=16) cbf_x0   	 = cu_x0 & ((1<<tu_log2TrafoSize)-1),
                uint(size=16) cbf_y0   	 = cu_y0 & ((1<<tu_log2TrafoSize)-1)			
	do
		if DEBUG_CABAC and DEBUG_TRACE1 then
			println("read_TransformUnit.start("+tu_x0+", "+tu_y0+", "+tu_xBase+", "+tu_yBase+", "+
					tu_log2TrafoSize+", "+tu_log2TrafoSize+", "+tu_trafoDepth+", "+tu_blkIdx+")");
		elsif DEBUG_CABAC then
			println("read_TransformUnit.start");
		end
				if cbf_luma = 1 or cbf_cb[cbf_x0][cbf_y0][tu_trafoDepth] = 1 or
			cbf_cr[ cbf_x0 ][ cbf_y0 ][ tu_trafoDepth ] = 1 then
                	if pps_cu_qp_delta_enabled_flag[pps_id] != 0 and IsCuQpDeltaCoded = 0 then
                		get_CU_QP_DELTA_ABS(codIRange, codIOffset, ctxTable, fifo, res);
				 CuQpDelta := res[0];
				 if CuQpDelta != 0 then
                			get_CU_QP_DELTA_SIGN_FLAG(codIRange, codIOffset, fifo, res);
					 if res[0] = 1 then
						CuQpDelta := -CuQpDelta;
					 end
				 end
				IsCuQpDeltaCoded := 1;
						set_qPy();
						  end
						end

		tu_idx				:= 8; // skipResidualCoding
		rc_x0 				:= tu_x0;
		rc_y0 				:= tu_y0;
		rc_log2TrafoSize	:= tu_log2TrafoSize;
		rc_scanIdx			:= getScanIdx(predMode, tu_log2TrafoSize, cur_intra_pred_mode);
		rc_cIdx				:= TEXT_LUMA;
		if cbf_luma = 1 then
			tu_idx 			:= 2;
		end
	end
	/**************************************************************************
	 * read_TransformUnit.retLuma
	 *************************************************************************/
	read_TransformUnit.retLuma : action ==>
	guard
		tu_idx = 3
	var
		uint(size=16) cbf_x0			= tu_x0 & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_y0			= tu_y0 & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_xBase			= tu_xBase & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_yBase			= tu_yBase & ((1<<tu_log2TrafoSize)-1)
	do
		tu_idx 				:= 5;
		rc_log2TrafoSize	:= tu_log2TrafoSize;
		rc_scanIdx			:= getScanIdx(predMode, rc_log2TrafoSize, intra_pred_mode_c);
		rc_cIdx				:= TEXT_CHROMA_U;
		if tu_log2TrafoSize > 2 then
			tu_idx 				:= 10;  // skipResidualCoding
			rc_x0 				:= tu_x0;
			rc_y0 				:= tu_y0;
			rc_log2TrafoSize	:= tu_log2TrafoSize - 1;
			if cbf_cb[ cbf_x0 ][ cbf_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx			:= 4;
			end
		elsif tu_blkIdx = 3 then
			tu_idx 			:= 10;  // skipResidualCoding
			rc_x0    		:= tu_xBase;
			rc_y0 	 		:= tu_yBase;
			if cbf_cb[ cbf_xBase ][ cbf_yBase ][ tu_trafoDepth ] = 1 then
				tu_idx		:= 4;
			end
		end
	end
	/**************************************************************************
	 * read_TransformUnit.retCb
	 *************************************************************************/
	read_TransformUnit.retCb : action ==>
	guard
		tu_idx = 5
	var
		uint(size=16) cbf_x0			= tu_x0 & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_y0			= tu_y0 & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_xBase			= tu_xBase & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_yBase			= tu_yBase & ((1<<tu_log2TrafoSize)-1)
	do
		tu_idx	 := 7;
		rc_cIdx	 := TEXT_CHROMA_V;
		if tu_log2TrafoSize > 2 then
			tu_idx	 			:= 12;  // skipResidualCoding
			rc_log2TrafoSize	:= tu_log2TrafoSize - 1;
			if cbf_cr[ cbf_x0 ][ cbf_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx 			:= 6;
			end
		elsif tu_blkIdx = 3 then
			tu_idx	 := 12;  // skipResidualCoding
			if cbf_cr[ cbf_xBase ][ cbf_yBase ][ tu_trafoDepth ] = 1 then
				tu_idx			:= 6;
			end
		end
	end
	/**************************************************************************
	 * read_TransformUnit_gotoResidualCoding
	 *************************************************************************/
	read_TransformUnit_gotoResidualCoding : action ==>
	guard
		tu_idx = 2 or tu_idx = 4 or tu_idx = 6
	do
		tu_idx := tu_idx + 1;
	end
	/**************************************************************************
	 * read_TransformUnit.skipResidualCoding
	 *************************************************************************/
	read_TransformUnit.skipResidualCoding : action ==> TUSize:[1<<rc_log2TrafoSize, 2, 0, 0, slice_qp, rc_cIdx, 0]
	guard
		tu_idx = 8 or tu_idx = 10 or tu_idx = 12
	do
		tu_idx := tu_idx - 5;
	end

	/**************************************************************************
	 * read_TransformUnit_end
	 *************************************************************************/
	read_TransformUnit_end : action ==>
	guard
		tu_idx = 7
	do
		if DEBUG_CABAC then
			println("read_TransformUnit_end");
		end
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Residual Coding                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size=16) rc_x0;
	uint(size=16) rc_y0;
	uint(size= 8) rc_log2TrafoSize;
	uint(size= 8) rc_scanIdx;
	uint(size= 8) rc_cIdx;
	//
	uint(size= 8) ScanOrder[4][3][(BLW_WIDTH_MAX/4)*(BLW_HEIGHT_MAX/4)][2];
	uint(size= 8) significant_coeff_flag_idx[16];
	uint(size= 8) nb_significant_coeff_flag;
	uint(size= 1) coded_sub_block_flag[8][8];
        uint(size= 8) LastSignificantCoeffX;
        uint(size= 8) LastSignificantCoeffY;

	uint(size=16) num_coeff;

	/**************************************************************************
	 * read_ResidualCoding.start
	 *************************************************************************/
	uint(size= 8) rc_lastScanPos;
	 int(size= 8) rc_lastSubBlock;
	 int(size= 8) rc_i;
	 int(size= 16) tabTransCoeffLevel[32*32];
	 int add;
	 int scale;
	 int scale_m;
	 int dc_scale := 16;
	 uint(size=8) scale_matrix [64];
	 uint(size= 8) shift;
		 int(size= 8) qp_y := 0;
		 int(size=16) qp;


		read_ResidualCoding.start : action ==> TUSize:[sz, 0, isDST, transform_skip_flag, slice_qp, rc_cIdx,
											if rc_cIdx = TEXT_CHROMA_U then
												pps_cb_qp_offset[pps_id] + slice_cb_qp_offset
											else
												pps_cr_qp_offset[pps_id] + slice_cr_qp_offset
																						end]
	guard
		isFifoFull(fifo)
	var
		 int(size=32) res[1],
//        uint(size=16) xS := 0,
//        uint(size=16) yS := 0,
//         int(size=16) xC := -1,
//         int(size=16) yC := -1,
		 int sz = 1 << rc_log2TrafoSize,
		 uint(size=1) transform_skip_flag,
		 int matrix_id,
		 int qp_offset,
		 int(size=16) qp_i,

		 int x_cg_last_sig,
		 int y_cg_last_sig,
		 int last_x_c,
		 int last_y_c,


		uint(size= 8) qp_c[15] = [ 29, 30, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37],
		uint(size= 8) levelScale[6] = [ 40, 45, 51, 57, 64, 72 ],
		 uint(size=1) isDST = if (predMode = INTRA and rc_cIdx = TEXT_LUMA and sz = 4) then 1 else 0 end
	do
		if DEBUG_CABAC and DEBUG_TRACE1 then
			println("read_ResidualCoding.start "+if rc_cIdx = TEXT_LUMA then "cbY" elsif rc_cIdx = TEXT_CHROMA_U then "cbU" else "cbV" end+"("+rc_x0+", "+rc_y0+", "+rc_log2TrafoSize+", "+rc_scanIdx+", "+rc_cIdx+")");
		elsif DEBUG_CABAC then
			println("read_ResidualCoding.start "+if rc_cIdx = TEXT_LUMA then "cbY" elsif rc_cIdx = TEXT_CHROMA_U then "cbU" else "cbV" end);
		end


		shift := if rc_cIdx = 0 then sps_bit_depth_luma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5
							  else sps_bit_depth_chroma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 end;
		if rc_cIdx = 0 then
			qp := qp_y + qp_bd_offset_luma;
		else
			if rc_cIdx = 1 then
				qp_offset := pps_cb_qp_offset[pps_id] + slice_cb_qp_offset;
			else
				qp_offset := pps_cr_qp_offset[pps_id] + slice_cr_qp_offset;
			end
			qp_i := clip_i32(qp_y + qp_offset, - qp_bd_offset_luma, 57);
			if qp_i < 30 then
				qp := qp_i;
			elsif qp_i > 43 then
				qp := qp_i - 6;
			else
				qp := qp_c[qp_i - 30];
			end
				qp := qp + qp_bd_offset_luma;
		end
		add := 1 << (shift - 1 );
		scale := levelScale[ rem6[qp] ] << (div6[qp]);
		scale_m := 16;
		if sps_scaling_list_enabled_flag[sps_id] = 1 then
			matrix_id := if predMode != INTRA then 1 else 0 end;

			if rc_log2TrafoSize != 5 then
				matrix_id := 3 * matrix_id + rc_cIdx;
			end
			if pps_scaling_list_data_present_flag[pps_id] = 1 then
				foreach int i in 0 .. 63 do
					scale_matrix[i] := pps_sl[pps_id][rc_log2TrafoSize - 2][matrix_id][i];
				end
				if rc_log2TrafoSize >= 4 then
					dc_scale := pps_sl_dc[pps_id][rc_log2TrafoSize - 4][matrix_id];
				end
			else
				foreach int i in 0 .. 63 do
					scale_matrix[i] := sps_sl[sps_id][rc_log2TrafoSize - 2][matrix_id][i];
				end
				if rc_log2TrafoSize >= 4 then
					dc_scale := sps_sl_dc[sps_id][rc_log2TrafoSize - 4][matrix_id];
				end
			end
		end

		foreach int i in 0 .. sz * sz - 1 do
			tabTransCoeffLevel[i] := 0;
		end
		coded_sub_block_flag := [[0	: for int j in 0 .. 7]	: for int i in 0 .. 7];
		if pps_transform_skip_enabled_flag[pps_id] = 1 and cu_transquant_bypass_flag = 0 and
			rc_log2TrafoSize = 2 then
			get_TRANSFORM_SKIP_FLAG(codIRange, codIOffset, ctxTable, fifo, res, rc_cIdx);
			transform_skip_flag := res[0];
		else
			transform_skip_flag := 0;
		end

		get_LAST_SIGNIFICANT_COEFF_X_PREFIX(codIRange, codIOffset, ctxTable, fifo, res, rc_log2TrafoSize, rc_cIdx);
		LastSignificantCoeffX := res[0];
		get_LAST_SIGNIFICANT_COEFF_Y_PREFIX(codIRange, codIOffset, ctxTable, fifo, res, rc_log2TrafoSize, rc_cIdx);
		LastSignificantCoeffY := res[0];
		if LastSignificantCoeffX > 3 then
			get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(codIRange, codIOffset, fifo, res, LastSignificantCoeffX);
			LastSignificantCoeffX := (1 << ((LastSignificantCoeffX >> 1) - 1)) *
									 (2  +  (LastSignificantCoeffX & 1 )) + res[0];
		end
		if LastSignificantCoeffY > 3 then
			get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(codIRange, codIOffset, fifo, res, LastSignificantCoeffY);
			LastSignificantCoeffY := (1 << ((LastSignificantCoeffY >> 1) - 1)) *
									 (2  +  (LastSignificantCoeffY & 1 )) + res[0];
		end


		if rc_scanIdx = SCAN_VER then
			res[0] := LastSignificantCoeffX;
			LastSignificantCoeffX := LastSignificantCoeffY;
			LastSignificantCoeffY := res[0];
		end

		x_cg_last_sig := LastSignificantCoeffX >> 2;
		y_cg_last_sig := LastSignificantCoeffY >> 2;

		if rc_scanIdx = 0 then
		  last_x_c := LastSignificantCoeffX & 3;
		  last_y_c := LastSignificantCoeffY & 3;

		  num_coeff := diag_scan4x4_inv[last_y_c][last_x_c];

		  if rc_log2TrafoSize = 3 then
			num_coeff := (num_coeff + (diag_scan2x2_inv[y_cg_last_sig][x_cg_last_sig] << 4));
		  elsif rc_log2TrafoSize = 4 then
			num_coeff := (num_coeff + (diag_scan4x4_inv[y_cg_last_sig][x_cg_last_sig] << 4));
		   else // rc_log2TrafoSize = 5 then
			num_coeff := (num_coeff + (diag_scan8x8_inv[y_cg_last_sig][x_cg_last_sig] << 4));
		  end

		elsif rc_scanIdx = 1 then
		  num_coeff := horiz_scan8x8_inv[LastSignificantCoeffY][LastSignificantCoeffX];

		elsif rc_scanIdx = 2 then
		  num_coeff := horiz_scan8x8_inv[LastSignificantCoeffX][LastSignificantCoeffY];
		end

		num_coeff := num_coeff + 1;
		rc_lastSubBlock := (num_coeff - 1) >> 4;
		rc_lastScanPos := num_coeff - (rc_lastSubBlock << 4) - 1;

		rc_i := rc_lastSubBlock;
	end

	/**************************************************************************
	 * read_ResidualCoding.for_numLastSubset.start
	 *************************************************************************/
	uint(size=16) rc_xS;
	uint(size=16) rc_yS;
	 int(size= 8) m_end;
	read_ResidualCoding.for_numLastSubset.start : action ==>
	guard
		isFifoFull(fifo)
	var
		int(size=32) res[1],
		uint(size= 8) n,
		uint(size=16) xC,
		uint(size=16) yC,
		uint(size= 1) inferSigCoeffFlag
	do
		rc_xS := ScanOrder[rc_log2TrafoSize-2][ rc_scanIdx ][ rc_i ][ 0 ];
		rc_yS := ScanOrder[rc_log2TrafoSize-2][ rc_scanIdx ][ rc_i ][ 1 ];
		inferSigCoeffFlag := 0;
		if rc_i < rc_lastSubBlock and rc_i > 0 then
			get_CODED_SUB_BLOCK_FLAG( codIRange, codIOffset, ctxTable, fifo, res, coded_sub_block_flag, rc_xS, rc_yS, rc_cIdx, rc_log2TrafoSize);
			coded_sub_block_flag[ rc_xS ][ rc_yS ] := res[0];
			inferSigCoeffFlag := 1;
		else
			if (rc_xS = LastSignificantCoeffX>>2 and rc_yS = LastSignificantCoeffY>>2) or (rc_xS = 0 and rc_yS = 0) then
				coded_sub_block_flag[ rc_xS ][ rc_yS ] := 1;
			end
		end

		m_end                     := 15;
		nb_significant_coeff_flag := 0;
		if rc_i = rc_lastSubBlock then
			m_end                         := rc_lastScanPos - 1;
			significant_coeff_flag_idx[0] := rc_lastScanPos;
			nb_significant_coeff_flag     := 1;
		end
		foreach int m in 0 .. m_end do
			n  := m_end - m;
			xC := ( rc_xS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 0 ];
			yC := ( rc_yS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 1 ];
			if coded_sub_block_flag[ rc_xS ][ rc_yS ] = 1 and ( n > 0 or inferSigCoeffFlag = 0 ) then
				get_SIGNIFICANT_COEFF_FLAG( codIRange, codIOffset, ctxTable, fifo, res, coded_sub_block_flag, xC, yC, rc_cIdx, rc_log2TrafoSize, rc_scanIdx);
				if res[0] = 1 then
					significant_coeff_flag_idx[nb_significant_coeff_flag] := n;
					nb_significant_coeff_flag := nb_significant_coeff_flag + 1;
					inferSigCoeffFlag := 0;
				end
			else
				if (xC = LastSignificantCoeffX and yC = LastSignificantCoeffY) or
				   (( (xC&3) = 0 and (yC&3) = 0) and inferSigCoeffFlag = 1 and coded_sub_block_flag[ rc_xS ][ rc_yS ] = 1 ) then
					significant_coeff_flag_idx[nb_significant_coeff_flag] := n;
					nb_significant_coeff_flag := nb_significant_coeff_flag + 1;
				end
			end
		end
		m_end := nb_significant_coeff_flag-1;
	end
	/**************************************************************************
	 * read_ResidualCoding_end
	 *************************************************************************/
	read_ResidualCoding_end.xIT4 : action ==>
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 4 * 4 - 1]] repeat 4 * 4
	guard
		rc_i < 0,
		rc_log2TrafoSize = 2
	do
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
	end

	read_ResidualCoding_end.xIT8 : action ==>
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 8 * 8 - 1]] repeat 8 * 8
	guard
		rc_i < 0,
		rc_log2TrafoSize = 3
	do
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
	end

	read_ResidualCoding_end.xIT16 : action ==>
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 16 * 16 - 1]] repeat 16 * 16
	guard
		rc_i < 0,
		rc_log2TrafoSize = 4
	do
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
	end

	read_ResidualCoding_end.xIT32 : action ==>
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 32 * 32 - 1]] repeat 32 * 32
	guard
		rc_i < 0,
		rc_log2TrafoSize = 5
	do
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
	end
	/**************************************************************************
	 * read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_GREATER1_FLAG
	 *************************************************************************/
	uint(size= 8) rc_ctxSet[1];
	uint(size= 8) rc_greater1Ctx[1];
	uint(size= 8) rc_firstSigScanPos;
	 int(size= 8) rc_firstGreater1ScanPos;
	 int(size= 8) rc_m;
	uint(size= 8) coeff_abs_level_greater1_flag[16];
	uint(size= 8) coeff_abs_level_greater2_flag;
	uint(size=16) coeff_sign_flag;
	uint(size= 1) rc_signHidden;
	read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_GREATER1_FLAG : action ==>
	guard
		isFifoFull(fifo)
	var
		 int(size=32) res[1] := [0],
		 int          n,
		 int(size= 8) lastSigScanPos  := -1,
		uint(size= 8) numGreater1Flag :=  0,
		uint(size= 9) ctxIdxInc[1]
	do
		rc_firstSigScanPos		:= 16;
		rc_firstGreater1ScanPos	:= -1;
		coeff_abs_level_greater1_flag := [ 0 : for int i in 0 .. 15 ];
		foreach int m in 0 .. m_end do
			n  := significant_coeff_flag_idx[m];
			if numGreater1Flag < 8 then
							context_93315(rc_cIdx, rc_i, numGreater1Flag = 0,
							rc_i = rc_lastSubBlock, rc_ctxSet, rc_greater1Ctx,
							ctxIdxInc);
							get_COEFF_ABS_LEVEL_GREATER1_FLAG(codIRange,
							codIOffset, ctxTable, fifo, res, ctxIdxInc[0]);
				if res[0] = 1 then
					rc_greater1Ctx[0] := 0;
								elsif rc_greater1Ctx[0] > 0 and rc_greater1Ctx[0] <
								3 then rc_greater1Ctx[0] := rc_greater1Ctx[0] + 1;
				end
				coeff_abs_level_greater1_flag[ n ] := res[0];
				numGreater1Flag := numGreater1Flag + 1;
							if (coeff_abs_level_greater1_flag[n] = 1 and
							rc_firstGreater1ScanPos = -1) then
					rc_firstGreater1ScanPos := n;
				end
			end
			if lastSigScanPos = -1 then
				lastSigScanPos := n;
			end
			rc_firstSigScanPos := n;
		end

		rc_signHidden := if lastSigScanPos - rc_firstSigScanPos > 3 and cu_transquant_bypass_flag = 0 then 1 else 0 end;
		if rc_firstGreater1ScanPos != -1 then
			get_COEFF_ABS_LEVEL_GREATER2_FLAG(codIRange, codIOffset, ctxTable, fifo, res, rc_cIdx, rc_ctxSet[0]);
			coeff_abs_level_greater2_flag := res[0];
		end
		if (pps_sign_data_hiding_flag[pps_id] = 0 or rc_signHidden = 0) then
			get_COEFF_SIGN_FLAG(codIRange, codIOffset, fifo, res, nb_significant_coeff_flag);
			coeff_sign_flag := res[0] << (16 - nb_significant_coeff_flag);
		else
			get_COEFF_SIGN_FLAG(codIRange, codIOffset, fifo, res, nb_significant_coeff_flag - 1);
			coeff_sign_flag := res[0] << (16 - (nb_significant_coeff_flag - 1));
		end
		rc_numSigCoeff		:= 0;
		rc_sumAbsLevel		:= 0;
		rc_cLastRiceParam	:= 0;
		rc_m   := 0;
	end
	/**************************************************************************
	 * read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL
	 *************************************************************************/
	uint(size= 8) rc_numSigCoeff;
	uint(size= 8) rc_sumAbsLevel;
	uint(size= 8) rc_cLastRiceParam;


	read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL : action ==>
	guard
		isFifoFull(fifo)
	var
		 int(size=32) res[1] := [0],
		 int          n       = significant_coeff_flag_idx[rc_m],
		 int(size=16) transCoeffLevel := 0,
		 int pos,
		uint(size=16) xC,
		uint(size=16) yC
	do
		xC := ( rc_xS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 0 ];
		yC := ( rc_yS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 1 ];
		transCoeffLevel := 1 + coeff_abs_level_greater1_flag[ n ] + if n = rc_firstGreater1ScanPos then coeff_abs_level_greater2_flag else 0 end;
		if transCoeffLevel = ( if rc_numSigCoeff < 8 then if n = rc_firstGreater1ScanPos then 3 else 2 end else 1 end) then
			get_COEFF_ABS_LEVEL(codIRange, codIOffset, fifo, res, rc_cLastRiceParam);
			transCoeffLevel := transCoeffLevel + res[0];
			rc_cLastRiceParam := min(if transCoeffLevel> 3 * ( 1 << rc_cLastRiceParam ) then rc_cLastRiceParam + 1 else rc_cLastRiceParam end, 4);
		end
		if pps_sign_data_hiding_flag[pps_id] = 1 and rc_signHidden = 1 then
			rc_sumAbsLevel := rc_sumAbsLevel + transCoeffLevel;
			if n = rc_firstSigScanPos and ( rc_sumAbsLevel & 1 ) = 1 then
				transCoeffLevel := - transCoeffLevel;
			end
		end
		if (coeff_sign_flag >> 15) = 1 then
			transCoeffLevel := - transCoeffLevel;
		end
		coeff_sign_flag := coeff_sign_flag << 1;

		if cu_transquant_bypass_flag = 0 then
			if sps_scaling_list_enabled_flag[sps_id] = 1 then
				if yC != 0 or xC != 0 or (rc_log2TrafoSize < 4) then
					if rc_log2TrafoSize = 3 then
						pos := (yC << 3) + xC;
					elsif rc_log2TrafoSize = 4 then
						pos := ((yC >> 1) << 3) + (xC >> 1);
					elsif rc_log2TrafoSize = 5 then
						pos := ((yC >> 2) << 3) + (xC >> 2);
					else
						pos := (yC << 2) + xC;
					end
					scale_m := scale_matrix[pos];
				else
					scale_m := dc_scale;
				end
			end
			transCoeffLevel := clip_i32(( ( transCoeffLevel * scale_m * scale + add )) >> shift, -32768, 32767 );
		end

		tabTransCoeffLevel[xC+(1<<rc_log2TrafoSize)*yC] := transCoeffLevel;
		rc_numSigCoeff := rc_numSigCoeff + 1;
		rc_m := rc_m + 1;
	end

	read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_end : action ==>
	guard
		rc_m > m_end
	do
		rc_i	:= rc_i - 1;
	end


	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/


	/**************************************************************************
	 **************************************************************************
	 ********        schedule                             *********************
	 **************************************************************************
	 *************************************************************************/
	schedule fsm start_code:
		// byte align
		byte_align          			( byte_align_a						) --> start_code;
		// search start code
		start_code          			( start_code.search					) --> start_code;
		start_code			            ( start_code.done					) --> read_Nal_unit_header;
		// read Nal Unit header
		read_Nal_unit_header			( read_nal_unit_header				) --> find_header;
		find_header	  					( look_for.VPS_header	  			) --> read_VPS_Header;
		find_header	  					( look_for.SEI_header	  			) --> read_SEI_Header;
		find_header	  					( look_for.SPS_header	  			) --> read_SPS_Header;
		find_header	  					( look_for.PPS_header	  			) --> read_PPS_Header;
		find_header	  					( look_for.Slice_header	  			) --> read_SliceHeader;
		// read VPS header
		read_VPS_Header	  				( read_VPS_Header	    			) --> read_VPS_Header;
		read_VPS_Header	  				( read_VPS_Header_done    			) --> byte_align;
		// read SEI header
		read_SEI_Header	  				( read_SEI_Header	    			) --> read_SEI_Header;
		read_SEI_Header	  				( read_SEI_Header_done    			) --> byte_align;
		// read SPS header
		read_SPS_Header	  				( read_SPS_Header	    			) --> read_SPS_Header;
		read_SPS_Header	  				( read_SPS_Header_done    			) --> byte_align;
		// read PPS header
		read_PPS_Header 				( read_PPS_Header   				) --> read_PPS_Header;
		read_PPS_Header	  				( read_PPS_Header_done    			) --> byte_align;
		// read_SliceHeader
		read_SliceHeader				( read_SliceHeader					) --> read_SliceHeader;
        read_SliceHeader                ( weighted_start                    ) --> weightedLuma0;
		read_SliceHeader				( read_SliceHeader_done				) --> read_SliceData;
		read_SliceHeader				( read_SliceHeader_done_bypass		) --> byte_align;
        //weightedPred
        weightedLuma0									(weighted_luma_l0								) --> weightedLuma0;
        weightedLuma0									(weighted_end_luma_l0							) --> weightedChroma0; 
        weightedChroma0									(weighted_chroma_l0								) --> weightedChroma0;
        weightedChroma0									(weighted_end_chroma_l0 						) --> weightedDeltaLuma0;
        weightedDeltaLuma0								(weighted_deltaLuma_l0_skip_loop				) --> weightedDeltaLuma0;
        weightedDeltaLuma0								(weighted_deltaLuma_l0_skip_loop_done			) --> weightedLuma1;
        weightedDeltaLuma0								(weighted_deltaLuma_l0__skip_all				) --> read_SliceHeader;
        weightedDeltaLuma0								(weighted_deltaLuma_l0_send						) --> weightedDeltaChroma0;
        weightedDeltaLuma0								(weighted_deltaLuma_l0_skip						) --> weightedDeltaChroma0;
        weightedDeltaChroma0							(weighted_deltaChroma_l0_skip					) --> weightedDeltaLuma0;
        weightedDeltaChroma0							(weighted_deltaChroma_l0_send					) --> weightedChroma0Offset;
        weightedChroma0Offset							(weighted_deltaChroma_offset_l0_send			) --> weightedDeltaLuma0;
        
        weightedLuma1									(weighted_luma_l1								) --> weightedLuma1;	
        weightedLuma1									(weighted_end_luma_l1							) --> weightedChroma1;
        weightedChroma1									(weighted_chroma_l1								) --> weightedChroma1;
        weightedChroma1									(weighted_chroma_l1_skip						) --> weightedDeltaLuma1;
        weightedChroma1									(weighted_end_chroma_l1							) --> weightedDeltaLuma1;
        weightedDeltaLuma1								(weighted_deltaLuma_l1_skip_loop				) --> weightedDeltaLuma1;
        weightedDeltaLuma1								(weighted_deltaLuma_l1_skip_loop_done			) --> read_SliceHeader;
        weightedDeltaLuma1								(weighted_deltaLuma_l1_send						) --> weightedDeltaChroma1;
        weightedDeltaLuma1								(weighted_deltaLuma_l1_skip						) --> weightedDeltaChroma1;
        weightedDeltaChroma1							(weighted_deltaChroma_l1_skip					) --> weightedDeltaLuma1;
        weightedDeltaChroma1							(weighted_deltaChroma_l1_send					) --> weightedChroma1Offset;
        weightedChroma1Offset							(weighted_deltaChroma_offset_l1_send			) --> weightedDeltaLuma1;
		// read_SliceData
		read_SliceData				    ( read_SliceData	  				) --> read_SliceData;
		read_SliceData				    ( read_SliceData_gotoCodingTree		) --> read_CodingTree;
		read_SliceData				    ( read_SliceData_end	  			) --> byte_align;
		// read_CodingTree
		read_CodingTree				    ( read_CodingTree	  				) --> read_CodingTree;
		read_CodingTree				    ( read_CodingTree_gotoSaoParam		) --> read_SaoParam;
		read_CodingTree				    ( read_CodingTree_gotoCodingQuadTree) --> read_CodingQuadTree;
		read_CodingTree				    ( read_CodingTree_end	 			) --> read_SliceData;
		// read_SaoParam
		read_SaoParam					( read_SaoParam						) --> read_SaoParam;
		read_SaoParam					( read_SaoParam_endLoop				) --> read_CodingTree;
		// read_CodingQuadTree
		read_CodingQuadTree			    ( read_CodingQuadTree	  				) --> read_CodingQuadTree;
		read_CodingQuadTree			    ( read_CodingQuadTree_gotoCodingUnit	) --> read_CodingUnit;
		read_CodingQuadTree				( read_CodingQuadTree_end	 			) --> read_CodingTree;
		// read_CodingUint
		read_CodingUnit				    ( read_CodingUnit                   ) --> read_CodingUnit;
		read_CodingUnit				    ( read_CodingUnit_noGoto1           ) --> send_IntraPredMode;
		read_CodingUnit				    ( read_CodingUnit_gotoPCMSample		) --> read_PCMSample;
		read_CodingUnit				    ( read_CodingUnit_gotoPredictionUnit) --> read_PredictionUnit;
		read_CodingUnit				    ( read_CodingUnit_gotoTransformTree ) --> read_TransformTree;
		read_CodingUnit                 ( read_CodingUnit_end               ) --> sendQp;
    	sendQp							(read_CodingUnit_end_sendQp			) --> read_CodingQuadTree;

		send_IntraPredMode              (sendIntraPredMode                  ) --> read_CodingUnit;
		// read_PredictionUnit
		read_PredictionUnit			    ( read_PredictionUnit	  			) --> read_PredictionUnit;
		read_PredictionUnit			    ( read_PredictionUnit_gotoMVDCoding ) --> read_MVDCoding;
		read_PredictionUnit			    ( read_PredictionUnit_end			) --> read_CodingUnit;
		// read_MVDCoding
		read_MVDCoding				    ( read_MVDCoding.start	  			) --> read_MVDCoding_end;
		read_MVDCoding_end				( read_MVDCoding.ended	  			) --> read_PredictionUnit;
		// read_PCMSample
	    read_PCMSample                              ( read_PCMSample_start                              ) --> read_PCMSampleLoop;//read_PredictionUnit;
	    read_PCMSampleLoop							( read_PCMSample_skipLoop							) --> read_PCMSampleLoop;
	    read_PCMSampleLoop                          ( read_PCMSample_skipLoop_end                       ) --> read_CodingUnit;
		// read_TransformTree
		read_TransformTree			    ( read_TransformTree	  			) --> read_TransformTree;
		read_TransformTree			    ( read_TransformTree_gotoTransformUnit) --> read_TransformUnit;
		read_TransformTree			    ( read_TransformTree_end	  		) --> read_CodingUnit;
		// read_TransformUnit
		read_TransformUnit			    ( read_TransformUnit	  			) --> read_TransformUnit;
		read_TransformUnit			    ( read_TransformUnit_gotoResidualCoding) --> read_ResidualCoding;
		read_TransformUnit			    ( read_TransformUnit_end			) --> read_TransformTree;
		// read_ResidualCoding
		read_ResidualCoding				( read_ResidualCoding.start  		) --> read_ResidualCodingStart;
		read_ResidualCodingStart        ( read_ResidualCoding.for_numLastSubset.start ) --> read_ResidualCodingGreater1;
		read_ResidualCodingGreater1     ( read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_GREATER1_FLAG ) --> read_ResidualCodingGetCoeff;
		read_ResidualCodingGetCoeff     ( read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL ) --> read_ResidualCodingGetCoeff;
		read_ResidualCodingGetCoeff     ( read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_end ) --> read_ResidualCodingStart;
		read_ResidualCodingStart		( read_ResidualCoding_end			) --> read_TransformUnit;

		find_header                     ( look_for_other_header             ) --> byte_align;

		// undefined
                //undefined                       ( undefined           					                                    ) --> undefined;
	end

	/**************************************************************************
	 * priority
	 *************************************************************************/
	priority
				look_for        > look_for_other_header;
				read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_end > read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL;
				read_ResidualCoding_end > read_ResidualCoding.for_numLastSubset.start;
                weighted_end_luma_l0 											> weighted_luma_l0;
                weighted_end_chroma_l0 											> weighted_chroma_l0;
                weighted_deltaLuma_l0_skip_loop_done							> weighted_deltaLuma_l0_skip_loop;
                weighted_end_luma_l1 											> weighted_luma_l1;
                weighted_end_chroma_l1 											> weighted_chroma_l1;
                weighted_deltaLuma_l1_skip_loop_done							> weighted_deltaLuma_l1_skip_loop;
	end
end
